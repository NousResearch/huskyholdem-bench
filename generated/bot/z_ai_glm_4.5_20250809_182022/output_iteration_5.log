
================================================================================
TIMESTAMP: 2025-08-09 18:36:08
MODEL: z-ai/glm-4.5
PROMPT LENGTH: 11549 characters
RESPONSE LENGTH: 8307 characters
USAGE: {
  "prompt_tokens": 2662,
  "completion_tokens": 10782,
  "total_tokens": 13444,
  "prompt_tokens_details": null
}

PROMPT:

You are tasked with submitting a poker bot to a No-Limit Texas Hold'em poker bot competition: Husky Hold'em.

**Detailed Game Rules**
- No-Limit Texas Hold'em with 2-10 players (often 6-handed tables); bots compete in heads-up or multi-player matches hosted by a central game server.
- Players start with $10,000 chips at the simulation start; simulations run for n games (more than 10 per run); blinds rotate and increase every n games (e.g., after certain rounds); big/small blinds are posted pre-flop.
- Goal: Maximize delta money (ending chips minus starting chips); if a player runs out of chips, they are eliminated from that table; no rebuys.
- Each hand has 4 betting rounds: Pre-flop (after hole cards and blinds), Flop (3 community cards), Turn (1 community card), River (1 community card).
- Actions: Fold, Check, Call, Raise (any amount up to stack, no limit), All-in.
- Hand rankings: Royal flush > Straight flush > Four of a kind > Full house > Flush > Straight > Three of a kind > Two pair > One pair > High card.
- Showdown: If multiple players remain after river betting, best 5-card hand (using any combination of 2 hole cards + 5 community cards) wins the pot; side pots form for all-ins with eligible players.
- Technical Limits: 30 seconds max per move (timeout causes automatic fold); 100MB max memory usage; any error/exception causes automatic fold; all bots are given the same compute limits.

Your task: Implement winning bot in player.py by subclassing Bot as in the template below and follow the above game rules.

Bot Design and Competition Rules:

1. Your bot must subclass Bot as SimplePlayer, implementing all required methods exactly as in the template. Preserve the class name SimplePlayer for compatibility with the game server. The template for the class is as
**SimplePlayer Template:**
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        # TODO implement this

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        # TODO implement this

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # TODO implement this

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Returns the action for the player. """
        # TODO implement this

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        """ Called at the end of the round. """
        # TODO implement this

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # TODO implement this
```
2. DO NOT rename or remove any predefined methods (on_start, on_round_start, get_action, on_end_round, on_end_game), and do not change their signatures.
3. You may add helper functions and instance variables for strategy or tracking.
4. Your bot should be able to abide by no limit texas hold'em rules and handle side pots, all-ins, blind increases, multi-way pots, and be error-free (no exceptions).
5. For each action, always return valid actions:
    - For RAISE: the amount raise combine with your current bet must be larger than the the current raise.
    - For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call (current_bet - your bet).
    - For CHECK: You can't check if round's current bet is larger than 0. Resort to other action (eg CALL, RAISE, ALL_IN).
    - For ALL_IN: You don't need to specify the amount you all in, it will default to all your current money.
    - **INVALID ACTION WILL MAKE YOU LOSE MONEY (automatic result in fold if the condition is not match for each action), so logic must always check bounds and edge cases**.
6. If you use any external libraries, they must be listed in requirements.txt (pure Python only).
7. Implement your bot with SimplePlayer. See full RoundStateClient, PokerAction, and PokerRound definitions below.
8. Your bot should maximize delta money (ending chips minus starting chips). Positive mean gaining money, the more money you gain the better.
9. There might will be data on previous run (error and game score) if this is not the first time you implement. If there is error, fix it so your bot can run. Try to improve your bot from previous round.
10. If there are no usage of external requirements, the text secion for requirement must be empty. DO NOT PUT ANYTHING ELSE. If you want to use any external library, you must put it in that text block
11. Your response must consist ONLY of two files: the complete player.py (as a Python code block) implementing the bot with all template elements preserved plus your improvements, and requirements.txt (as a text block) listing any dependencies (pure Python only, e.g., numpy if needed for calculations). Do not include any other text, explanations, or outputs. See example response below:
Example response:
```python
<Your python code>
```

```text
numpy
matplotlib
<any external library you want to use, put it here>
...
```
12. Your implementation MUST BE IN FULL not putting stub method or guideline. Everything in SimplePlayer must be ready to the detail and ready to run.
13. When you do division, make sure to make it prone to error divide by zero by adding some small delta.
14. The pool of submitted bots, including your bot, will be organized into 6-handed poker tables where every possible combination of 6 bots forms a separate table. Each table will play exactly 1,000 hands, with chip stacks carrying over between hands within the same table. 
15. At the end of each table, delta money is calculated for each bot using the formula: final chip count minus 10,000 (initial chip amount). Your bot's total tournament score is determined by summing its delta money across all tables it participates in. The bot with the highest cumulative delta money across all tables wins the tournament.
16. Your bot will undergo iterative testing across 5 rounds, where each round involves playing 10 hands of heads-up poker against a house bot. After each round, you will receive either the complete game log showing performance results or any compilation/simulation errors that occurred while attempting to run your bot. Use this feedback to refine your implementation in subsequent iterations.

**References**

**RoundStateClient Full Definition:**
```python
from dataclasses import dataclass
from typing import Dict, List, Any

@dataclass
class RoundStateClient:
    round_num: int # The number of the current round
    round: str # e.g., 'Preflop', 'Flop', 'Turn', 'River'
    community_cards: List[str] # List of community cards, e.g., ['Ah', 'Ks', '3d']
    pot: int # The total pot
    current_player: List[int] # The ids of the current players
    current_bet: int # The current bet (need to match round's current bet minus your current bet if you want to call)
    min_raise: int  # Minimum raise amount
    max_raise: int  # Maximum raise amount (your remaining chips)
    player_bets: Dict[str, int]  # Bets by player ID
    player_actions: Dict[str, str]  # Actions by player ID, e.g., {'3336760419': 'Check', '3266396022': 'Check'}
    side_pots: list[Dict[str, any]] = None  # List of dicts with 'amount' and 'eligible_players' keys

    @classmethod
    def from_message(cls, message: Dict[str, Any]) -> 'RoundStateClient':
        """Create RoundStateClient from a message dictionary"""
        return cls(
            round_num=message['round_num'],
            round=message['round'],
            community_cards=message['community_cards'],
            pot=message['pot'],
            current_player=message['current_player'],
            current_bet=message['current_bet'],
            min_raise=message['min_raise'],
            max_raise=message['max_raise'],
            player_bets=message['player_bets'],
            player_actions=message['player_actions'],
            side_pots=message.get('side_pots', [])
        )
```

**PokerAction and PokerRound Enums:**
```python
from enum import Enum

class PokerAction(Enum):
    FOLD = 1
    CHECK = 2
    CALL = 3
    RAISE = 4
    ALL_IN = 5

class PokerRound(Enum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3
```

**Bot abstract class:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple

from type.round_state import RoundStateClient
from type.poker_action import PokerAction

class Bot(ABC):
    def __init__(self) -> None:
        """ Initializes the player. """
        self.id = None
        pass

    def set_id(self, player_id: int) -> None:
        """ Sets the player ID. """
        self.id = player_id

    @abstractmethod
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]) -> None:
        """ Called when the game starts. """
        pass

    @abstractmethod
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the start of each round. """
        pass

    @abstractmethod
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Called when it is the player's turn to act. """
        pass

    @abstractmethod
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the end of each round. """
        pass

    @abstractmethod
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict) -> None:
        """ Called at the end of the game. """
        pass
```

ITERATION 5 FEEDBACK AND IMPROVEMENT REQUEST:
You are now working on iteration 5. Based on the previous iteration results and code, please improve the implementation.

PREVIOUS RESULTS:
- Success: False
- Error Message: Error processing prompt: API request failed: 400 - {"error":{"message":"This endpoint's maximum context length is 131072 tokens. However, you requested about 134055 tokens (6055 of text input, 128000 in the output). Please reduce the length of either one, or use the \"middle-out\" transform to compress your prompt automatically.","code":400,"metadata":{"provider_name":null}}}

ERRORS ENCOUNTERED:
Error processing prompt: API request failed: 400 - {"error":{"message":"This endpoint's maximum context length is 131072 tokens. However, you requested about 134055 tokens (6055 of text input, 128000 in the output). Please reduce the length of either one, or use the \"middle-out\" transform to compress your prompt automatically.","code":400,"metadata":{"provider_name":null}}}

Please fix these specific errors in your implementation.

IMPROVEMENT INSTRUCTIONS:
1. You are on iteration 5 - build upon the previous code
2. Analyze the errors and game performance data above
3. Fix any syntax, import, or runtime errors from the previous iteration
4. Improve the poker strategy based on game results
5. Ensure the code follows the exact template requirements
6. Return the improved implementation in the same format (Python code block + requirements.txt block)

Focus on making the bot more competitive and error-free. You can see exactly what was wrong with the previous version and should fix those specific issues.


RESPONSE:
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        self.hand_groups = {
            'AA': 1, 'KK': 1, 'QQ': 1, 'JJ': 1, 'AKs': 1, 
            'AKo': 2, 'AQs': 2, 'AJs': 2, 'KQs': 2, 'TT': 3,
            'AQo': 3, 'ATs': 3, 'KJs': 3, 'QJs': 3, 'JTs': 3,
            '99': 4, 'A9s': 4, 'KTs': 4, 'QTs': 4, 'J9s': 4,
            'T9s': 4, '88': 5, 'A8s': 5, 'K9s': 5, 'Q9s': 5,
            'J8s': 5, 'T8s': 5, '98s': 5, '77': 6, 'A7s': 6,
            'K8s': 6, 'QTs': 6, 'JTs': 6, 'T7s': 6, '87s': 6,
            '66': 7, 'A6s': 7, 'K7s': 7, 'Q8s': 7, 'J9s': 7,
            'T9s': 7, '86s': 7, '76s': 7, '55': 8, 'A5s': 8,
            'K6s': 8, 'Q7s': 8, 'J7s': 8, 'T8s': 8, '96s': 8,
            '85s': 8, '75s': 8, '44': 9, 'A4s': 9, 'K5s': 9,
            'Q6s': 9, 'J6s': 9, 'T7s': 9, '97s': 9, '86s': 9,
            '65s': 9, '33': 10, 'A3s': 10, 'K4s': 10, 'Q5s': 10,
            'J5s': 10, 'T6s': 10, '95s': 10, '87s': 10, '76s': 10,
            '22': 11, 'A2s': 11, 'K3s': 11, 'Q4s': 11, 'J4s': 11,
            'T5s': 11, '96s': 11, '85s': 11, '75s': 11, '54s': 11
        }
        self.our_hand = None
        self.starting_chips = 10000
        self.blind_level = 0
        self.position_factor = 0
        self.rand = __import__('random')
        
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        self.starting_chips = starting_chips
        self.blind_level = blind_amount
        self.our_hand = player_hands
        
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        if round_state.current_player:
            player_count = len(round_state.current_player)
            try:
                our_index = round_state.current_player.index(self.id)
                self.position_factor = our_index / player_count
            except ValueError:
                self.position_factor = 0.5
                
    def get_hand_key(self, hand: List[str]) -> str:
        rank_order = 'AKQJT98765432'
        c1, c2 = hand[0], hand[1]
        r1, r2 = c1[0], c2[0]
        s1, s2 = c1[1], c2[1]
        
        if r1 == r2:
            return r1 + r2
            
        higher_r = r1 if rank_order.index(r1) < rank_order.index(r2) else r2
        lower_r = r2 if higher_r == r1 else r1
        suited = 's' if s1 == s2 else 'o'
        return higher_r + lower_r + suited
        
    def evaluate_hand_strength(self, hand: List[str], community_cards: List[str]) -> float:
        all_cards = hand + community_cards
        rank_vals = {'A':14, 'K':13, 'Q':12, 'J':11, 'T':10, '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2}
        ranks = [card[0] for card in all_cards]
        suits = [card[1] for card in all_cards]
        
        rank_count = {}
        suit_count = {}
        for rank in ranks:
            rank_count[rank] = rank_count.get(rank, 0) + 1
        for suit in suits:
            suit_count[suit] = suit_count.get(suit, 0) + 1
            
        counts = sorted(rank_count.values(), reverse=True)
        flush = max(suit_count.values()) >= 5
        straight = self.is_straight(ranks, rank_vals)
        
        if counts[0] == 4:
            return 0.95
        elif counts[0] == 3 and counts[1] == 2:
            return 0.9
        elif flush and straight:
            return 0.99
        elif flush:
            return 0.8
        elif straight:
            return 0.7
        elif counts[0] == 3:
            return 0.6
        elif counts[0] == 2 and counts[1] == 2:
            return 0.4
        elif counts[0] == 2:
            return 0.2
        else:
            max_rank = max(rank_vals[r] for r in ranks)
            return min(max_rank / 14.0, 0.15)
            
    def is_straight(self, ranks: List[str], rank_vals: dict) -> bool:
        unique_ranks = list(set(ranks))
        if len(unique_ranks) < 5:
            return False
        sorted_vals = sorted([rank_vals[r] for r in unique_ranks], reverse=True)
        
        for i in range(len(sorted_vals) - 4):
            if sorted_vals[i] - sorted_vals[i+4] == 4:
                return True
                
        if 14 in sorted_vals and 2 in sorted_vals and 3 in sorted_vals and 4 in sorted_vals and 5 in sorted_vals:
            return True
        return False
        
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        if not round_state.current_player:
            return PokerAction.FOLD, 0
            
        current_bet = round_state.current_bet
        our_bet = round_state.player_bets.get(str(self.id), 0)
        to_call = current_bet - our_bet
        pot = round_state.pot
        min_raise = round_state.min_raise
        max_raise = round_state.max_raise
        
        hand_key = self.get_hand_key(self.our_hand)
        hand_group = self.hand_groups.get(hand_key, 12)
        
        adjusted_group = hand_group - self.position_factor * 2
        
        if round_state.round == 'Preflop':
            if our_bet >= current_bet:  
                if adjusted_group <= 4 and self.rand.random() < 0.7:
                    if min_raise <= remaining_chips:
                        raise_amt = min(min_raise * 2, max_raise)
                        return PokerAction.RAISE, raise_amt
                return PokerAction.CHECK, 0
            else:
                if to_call == 0:
                    return PokerAction.CHECK, 0
                    
                pot_odds = to_call / (pot + to_call + 1e-6)
                
                if adjusted_group <= 2:
                    if min_raise <= remaining_chips and to_call < self.blind_level * 4:
                        raise_amt = min(min_raise * 2, max_raise, remaining_chips)
                        return PokerAction.RAISE, raise_amt
                    else:
                        return PokerAction.CALL, 0
                elif adjusted_group <= 5:
                    if pot_odds < 0.2 and to_call < self.blind_level * 3:
                        return PokerAction.CALL, 0
                    else:
                        return PokerAction.FOLD, 0
                else:
                    if pot_odds < 0.1 and to_call <= self.blind_level:
                        return PokerAction.CALL, 0
                    else:
                        return PokerAction.FOLD, 0
        else:
            hand_strength = self.evaluate_hand_strength(self.our_hand, round_state.community_cards)
            
            if our_bet >= current_bet:
                if hand_strength > 0.75:
                    bet_size = min(pot // 2, max_raise, remaining_chips)
                    if bet_size >= min_raise:
                        return PokerAction.RAISE, bet_size
                elif hand_strength > 0.6 and self.rand.random() < 0.5:
                    bet_size = min(pot // 3, max_raise, remaining_chips)
                    if bet_size >= min_raise:
                        return PokerAction.RAISE, bet_size
                return PokerAction.CHECK, 0
            else:
                pot_odds = to_call / (pot + to_call + 1e-6)
                
                if hand_strength > 0.85:
                    if min_raise <= remaining_chips:
                        raise_amt = min(min_raise * 2, max_raise, remaining_chips)
                        return PokerAction.RAISE, raise_amt
                    return PokerAction.CALL, 0
                elif hand_strength > 0.65:
                    if pot_odds < 0.3:
                        return PokerAction.CALL, 0
                    else:
                        return PokerAction.FOLD, 0
                elif hand_strength > 0.45 and pot_odds < 0.15:
                    return PokerAction.CALL, 0
                else:
                    return PokerAction.FOLD, 0
                    
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        pass
        
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        pass
```

```text
```

RAW API RESPONSE:
{
  "id": "gen-1754789532-p1v4TyWKLejytyFlUwsK",
  "provider": "Parasail",
  "model": "z-ai/glm-4.5",
  "object": "chat.completion",
  "created": 1754789532,
  "choices": [
    {
      "logprobs": null,
      "finish_reason": "stop",
      "native_finish_reason": "stop",
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Tuple\nfrom bot import Bot\nfrom type.poker_action import PokerAction\nfrom type.round_state import RoundStateClient\n\nclass SimplePlayer(Bot):\n    def __init__(self):\n        super().__init__()\n        self.hand_groups = {\n            'AA': 1, 'KK': 1, 'QQ': 1, 'JJ': 1, 'AKs': 1, \n            'AKo': 2, 'AQs': 2, 'AJs': 2, 'KQs': 2, 'TT': 3,\n            'AQo': 3, 'ATs': 3, 'KJs': 3, 'QJs': 3, 'JTs': 3,\n            '99': 4, 'A9s': 4, 'KTs': 4, 'QTs': 4, 'J9s': 4,\n            'T9s': 4, '88': 5, 'A8s': 5, 'K9s': 5, 'Q9s': 5,\n            'J8s': 5, 'T8s': 5, '98s': 5, '77': 6, 'A7s': 6,\n            'K8s': 6, 'QTs': 6, 'JTs': 6, 'T7s': 6, '87s': 6,\n            '66': 7, 'A6s': 7, 'K7s': 7, 'Q8s': 7, 'J9s': 7,\n            'T9s': 7, '86s': 7, '76s': 7, '55': 8, 'A5s': 8,\n            'K6s': 8, 'Q7s': 8, 'J7s': 8, 'T8s': 8, '96s': 8,\n            '85s': 8, '75s': 8, '44': 9, 'A4s': 9, 'K5s': 9,\n            'Q6s': 9, 'J6s': 9, 'T7s': 9, '97s': 9, '86s': 9,\n            '65s': 9, '33': 10, 'A3s': 10, 'K4s': 10, 'Q5s': 10,\n            'J5s': 10, 'T6s': 10, '95s': 10, '87s': 10, '76s': 10,\n            '22': 11, 'A2s': 11, 'K3s': 11, 'Q4s': 11, 'J4s': 11,\n            'T5s': 11, '96s': 11, '85s': 11, '75s': 11, '54s': 11\n        }\n        self.our_hand = None\n        self.starting_chips = 10000\n        self.blind_level = 0\n        self.position_factor = 0\n        self.rand = __import__('random')\n        \n    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):\n        self.starting_chips = starting_chips\n        self.blind_level = blind_amount\n        self.our_hand = player_hands\n        \n    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):\n        if round_state.current_player:\n            player_count = len(round_state.current_player)\n            try:\n                our_index = round_state.current_player.index(self.id)\n                self.position_factor = our_index / player_count\n            except ValueError:\n                self.position_factor = 0.5\n                \n    def get_hand_key(self, hand: List[str]) -> str:\n        rank_order = 'AKQJT98765432'\n        c1, c2 = hand[0], hand[1]\n        r1, r2 = c1[0], c2[0]\n        s1, s2 = c1[1], c2[1]\n        \n        if r1 == r2:\n            return r1 + r2\n            \n        higher_r = r1 if rank_order.index(r1) < rank_order.index(r2) else r2\n        lower_r = r2 if higher_r == r1 else r1\n        suited = 's' if s1 == s2 else 'o'\n        return higher_r + lower_r + suited\n        \n    def evaluate_hand_strength(self, hand: List[str], community_cards: List[str]) -> float:\n        all_cards = hand + community_cards\n        rank_vals = {'A':14, 'K':13, 'Q':12, 'J':11, 'T':10, '9':9, '8':8, '7':7, '6':6, '5':5, '4':4, '3':3, '2':2}\n        ranks = [card[0] for card in all_cards]\n        suits = [card[1] for card in all_cards]\n        \n        rank_count = {}\n        suit_count = {}\n        for rank in ranks:\n            rank_count[rank] = rank_count.get(rank, 0) + 1\n        for suit in suits:\n            suit_count[suit] = suit_count.get(suit, 0) + 1\n            \n        counts = sorted(rank_count.values(), reverse=True)\n        flush = max(suit_count.values()) >= 5\n        straight = self.is_straight(ranks, rank_vals)\n        \n        if counts[0] == 4:\n            return 0.95\n        elif counts[0] == 3 and counts[1] == 2:\n            return 0.9\n        elif flush and straight:\n            return 0.99\n        elif flush:\n            return 0.8\n        elif straight:\n            return 0.7\n        elif counts[0] == 3:\n            return 0.6\n        elif counts[0] == 2 and counts[1] == 2:\n            return 0.4\n        elif counts[0] == 2:\n            return 0.2\n        else:\n            max_rank = max(rank_vals[r] for r in ranks)\n            return min(max_rank / 14.0, 0.15)\n            \n    def is_straight(self, ranks: List[str], rank_vals: dict) -> bool:\n        unique_ranks = list(set(ranks))\n        if len(unique_ranks) < 5:\n            return False\n        sorted_vals = sorted([rank_vals[r] for r in unique_ranks], reverse=True)\n        \n        for i in range(len(sorted_vals) - 4):\n            if sorted_vals[i] - sorted_vals[i+4] == 4:\n                return True\n                \n        if 14 in sorted_vals and 2 in sorted_vals and 3 in sorted_vals and 4 in sorted_vals and 5 in sorted_vals:\n            return True\n        return False\n        \n    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:\n        if not round_state.current_player:\n            return PokerAction.FOLD, 0\n            \n        current_bet = round_state.current_bet\n        our_bet = round_state.player_bets.get(str(self.id), 0)\n        to_call = current_bet - our_bet\n        pot = round_state.pot\n        min_raise = round_state.min_raise\n        max_raise = round_state.max_raise\n        \n        hand_key = self.get_hand_key(self.our_hand)\n        hand_group = self.hand_groups.get(hand_key, 12)\n        \n        adjusted_group = hand_group - self.position_factor * 2\n        \n        if round_state.round == 'Preflop':\n            if our_bet >= current_bet:  \n                if adjusted_group <= 4 and self.rand.random() < 0.7:\n                    if min_raise <= remaining_chips:\n                        raise_amt = min(min_raise * 2, max_raise)\n                        return PokerAction.RAISE, raise_amt\n                return PokerAction.CHECK, 0\n            else:\n                if to_call == 0:\n                    return PokerAction.CHECK, 0\n                    \n                pot_odds = to_call / (pot + to_call + 1e-6)\n                \n                if adjusted_group <= 2:\n                    if min_raise <= remaining_chips and to_call < self.blind_level * 4:\n                        raise_amt = min(min_raise * 2, max_raise, remaining_chips)\n                        return PokerAction.RAISE, raise_amt\n                    else:\n                        return PokerAction.CALL, 0\n                elif adjusted_group <= 5:\n                    if pot_odds < 0.2 and to_call < self.blind_level * 3:\n                        return PokerAction.CALL, 0\n                    else:\n                        return PokerAction.FOLD, 0\n                else:\n                    if pot_odds < 0.1 and to_call <= self.blind_level:\n                        return PokerAction.CALL, 0\n                    else:\n                        return PokerAction.FOLD, 0\n        else:\n            hand_strength = self.evaluate_hand_strength(self.our_hand, round_state.community_cards)\n            \n            if our_bet >= current_bet:\n                if hand_strength > 0.75:\n                    bet_size = min(pot // 2, max_raise, remaining_chips)\n                    if bet_size >= min_raise:\n                        return PokerAction.RAISE, bet_size\n                elif hand_strength > 0.6 and self.rand.random() < 0.5:\n                    bet_size = min(pot // 3, max_raise, remaining_chips)\n                    if bet_size >= min_raise:\n                        return PokerAction.RAISE, bet_size\n                return PokerAction.CHECK, 0\n            else:\n                pot_odds = to_call / (pot + to_call + 1e-6)\n                \n                if hand_strength > 0.85:\n                    if min_raise <= remaining_chips:\n                        raise_amt = min(min_raise * 2, max_raise, remaining_chips)\n                        return PokerAction.RAISE, raise_amt\n                    return PokerAction.CALL, 0\n                elif hand_strength > 0.65:\n                    if pot_odds < 0.3:\n                        return PokerAction.CALL, 0\n                    else:\n                        return PokerAction.FOLD, 0\n                elif hand_strength > 0.45 and pot_odds < 0.15:\n                    return PokerAction.CALL, 0\n                else:\n                    return PokerAction.FOLD, 0\n                    \n    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):\n        pass\n        \n    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):\n        pass\n```\n\n```text\n```",
        "refusal": null,
        "reasoning": "We are given an error about token length. Since the previous iteration's code was cut off due to token limits, we must ensure the current code is concise and within token limits.\n\nGiven the context, we are to build upon the previous code, but we don't have the full previous code. However, we can design a bot from scratch that is efficient and meets the requirements.\n\nWe'll design a simple but effective bot that uses hand strength and position-based strategy. We'll avoid complex calculations that might lead to token overflow and focus on core features.\n\nKey features of the bot:\n1. Precomputed hand strengths for common scenarios to avoid heavy computation during the game.\n2. Position-aware adjustments (acting late vs early).\n3. Basic aggression based on hand strength.\n\nWe'll implement:\n- A helper function to evaluate hand strength (pre-flop, post-flop) based on hand charts and hand evaluation.\n- Use of a simple pre-flop chart for starting hands.\n- Post-flop: evaluate the current hand and potential to improve (outs calculation) but in a simplified manner.\n\nGiven the token constraints, we must keep the code as minimal as possible.\n\nWe'll structure the bot as follows:\n\n```python\nfrom typing import List, Tuple\nfrom bot import Bot\nfrom type.poker_action import PokerAction\nfrom type.round_state import RoundStateClient\nimport random\n\nclass SimplePlayer(Bot):\n    def __init__(self):\n        super().__init__()\n        # Precomputed hand groups (from Sklansky-Chubukov or similar)\n        self.hand_groups_pre_flop = {\n            'AA': 1, 'KK': 1, 'QQ': 1, 'JJ': 1, 'AKs': 1, 'AKo': 2, 'AQs': 2, 'AJs': 2, 'KQs': 2, \n            'TT': 3, 'AQo': 3, 'ATs': 3, 'KJs': 3, 'QJs': 3, 'JTs': 3, '99': 4, 'A9s': 4, \n            'KTs': 4, 'QTs': 4, 'J9s': 4, 'T9s': 4, 'A8s': 5, 'AJo': 5, 'KJo': 5, 'QJo': 5, \n            '88': 6, 'K9s': 6, 'QTs': 6, 'JTs': 6, 'T8s': 6, '77': 7, 'A9o': 7, 'Q9s': 7, \n            'J9s': 7, 'T9s': 7, '98s': 7, 'A7s': 8, 'A8o': 8, 'K8s': 8, 'K9o': 8, 'Q8s': 8, \n            'J8s': 8, 'T8s': 8, '87s': 8, '66': 9, 'A5s': 9, 'A6s': 9, 'A4s': 9, 'A3s': 9, \n            'A2s': 9, 'K7s': 9, 'K8o': 9, 'Q7s': 9, 'J7s': 9, 'T7s': 9, '97s': 9, '86s': 9, \n            '76s': 9, '55': 10, '44': 10, '33': 10, '22': 10\n        }\n        self.position_adjustment = {\n            'Button': 0,\n            'Small Blind': -1,\n            'Big Blind': -1,\n            'Early Position': -2,\n            'Middle Position': -1\n        }\n        self.our_hand = None\n        self.our_position = None\n        self.starting_chips = 10000\n        self.blind_amount = 0\n\n    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):\n        self.starting_chips = starting_chips\n        self.blind_amount = blind_amount\n        # We are not given our position in the list, but we can note our hand and later infer position by the order?\n        # The player_hands are given as a list of hands for each player? But note: the function signature says player_hands: List[str] but it's not clear how many.\n        # Actually, the documentation says: \"player_hands: List[str]\" - but it's for our bot? Or for all? \n        # Looking at the abstract method, it says: player_hands: List[str] - but in the context of our bot, it's likely the hand for our bot only? \n        # However, the parameters are the same for all bots. Let's see: the on_start method is called with:\n        #   starting_chips: int, \n        #   player_hands: List[str] -> This might be the hand for the current bot? Or for all? \n        # But the abstract class doesn't specify. We must assume that our bot only gets its own hand? \n        # The problem says: \"bots compete in heads-up or multi-player matches\", and the function is called at the start of the game for our bot.\n        # Therefore, player_hands for our bot should be a list of two strings? (our two hole cards) but it's a list of strings? \n        # Example: ['Ah', 'Ks'] for our hand.\n\n        # We assume that player_hands is the hand for our bot only, and it's a list of two strings.\n        self.our_hand = player_hands\n\n    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):\n        # We can determine our position relative to the blinds at the start of the round? \n        # But note: the round_state at round_start doesn't have the current_player? \n        # We'll store our hand and chips for the round.\n        self.our_chips = remaining_chips\n\n    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:\n        # RoundStateClient has: round, current_player, current_bet, min_raise, max_raise, etc.\n        # current_player: List[int] of current players (still in the hand). We need to find our position in the current_player list to see if we are in early, middle, or late.\n        # We can get our index in the current_player list. If we are the last, we are on the button? \n        # But note: the current_player list might not be in order? The problem doesn't specify. We assume it's in the order of play (from the small blind to the button? but actually the order of play is fixed: small blind, big blind, then UTG, ... until button).\n\n        # How to determine position? \n        # We know the table has 2-10 players. We are one of them. \n        # We can compute:\n        #   total_players = len(round_state.current_player)\n        #   our_index = round_state.current_player.index(self.id)\n        #   position = our_index / total_players   # 0 is first, 1 is next, ... total_players-1 is last (button)\n        # We can define:\n        #   late position: if our_index >= total_players - 2   (button and cutoff)\n        #   middle position: if total_players // 4 <= our_index < total_players - 2\n        #   early position: otherwise\n\n        total_players = len(round_state.current_player)\n        our_index = round_state.current_player.index(self.id)\n        position_factor = our_index / total_players  # 0 to 1\n\n        # Determine our group pre-flop for the hand\n        hand_key = self.get_hand_key(self.our_hand)\n        hand_group = self.hand_groups_pre_flop.get(hand_key, 11)  # if not found, group 11 (worst)\n\n        # Adjust hand group by position: better position (higher factor) means we can play weaker hands.\n        # We'll adjust the hand group by: hand_group = hand_group - (position_factor * 2)  # so maximum adjustment of 2 groups for late position\n        adjusted_group = hand_group - (position_factor * 2)\n\n        # Now, design a strategy for each street.\n\n        # Common variables\n        current_bet = round_state.current_bet\n        our_bet = round_state.player_bets.get(str(self.id), 0)\n        to_call = current_bet - our_bet\n        pot_odds = to_call / (round_state.pot + to_call) if (round_state.pot + to_call) > 0 else 0\n\n        # Pre-flop\n        if round_state.round == 'Preflop':\n            # If we are in the blinds and there was no raise, we can check.\n            if our_bet >= current_bet: \n                # We can check or raise?\n                # But note: pre-flop, we are in the blinds and there might be a raise? \n                # Actually, our_bet might be the blind we posted. If current_bet is still at the blind level (and no raise), then we can check.\n                # However, if there was a raise, then current_bet > our_bet (which is the blind) and we cannot check.\n                # So if we are in the blinds and no raise, we can check.\n                action = PokerAction.CHECK\n                amount = 0\n            else:\n                # We need to at least call the raise or fold.\n                # Based on adjusted_group and the raise amount.\n                if adjusted_group <= 3:\n                    # Strong hand: we can raise or call\n                    # If the pot odds are very low (small call) we can call, but we might want to raise to build the pot.\n                    # We'll raise to 3 times the current bet? but note: min_raise and max_raise.\n                    # We can raise by the min_raise? or a bit more.\n                    if to_call < self.blind_amount * 3:  # if the raise is small, we can call or raise\n                        # We'll raise to 3x the current bet? But note: current_bet is the amount to call to (if we call, we put to_call). \n                        # To raise: we must put at least current_bet + min_raise. \n                        # We'll raise by min_raise * 2? but we must not exceed max_raise.\n                        raise_amount = min(current_bet + min_raise * 2, remaining_chips)\n                        if raise_amount > current_bet:\n                            action = PokerAction.RAISE\n                            amount = raise_amount - our_bet  # because we have already put our_bet, so we need to put (raise_amount - our_bet) more.\n                        else:\n                            # We can't raise, so call?\n                            action = PokerAction.CALL\n                            amount = to_call\n                    else:\n                        # The raise is too big, so we call only if we have a premium hand (group 1 or 2)\n                        if adjusted_group <= 2:\n                            action = PokerAction.CALL\n                            amount = to_call\n                        else:\n                            action = PokerAction.FOLD\n                            amount = 0\n                elif adjusted_group <= 6:\n                    # Medium hand: call if the pot odds are good (say less than 20% of the pot to call) and the raise is small.\n                    if pot_odds < 0.2 and to_call < self.blind_amount * 4:\n                        action = PokerAction.CALL\n                        amount = to_call\n                    else:\n                        action = PokerAction.FOLD\n                        amount = 0\n                else:\n                    # Weak hand: fold\n                    action = PokerAction.FOLD\n                    amount = 0\n\n        # Post-flop: we'll do a simple hand strength and pot odds comparison.\n        else:\n            # Evaluate current hand strength on the flop, turn, river.\n            # We'll create a function to get a score for our hand and the board.\n            hand_score = self.evaluate_hand_strength(self.our_hand, round_state.community_cards)\n            # We'll define a threshold for raising, calling, etc.\n            # For simplicity, we can use:\n            #   hand_score >= 0.8: strong -> raise\n            #   hand_score >= 0.5: medium -> call if pot odds are good\n            #   else: fold unless we can check\n\n            # If we can check (current_bet <= our_bet), then we check if we have a weak hand? or we might bluff sometimes?\n            if current_bet <= our_bet:\n                if hand_score >= 0.7:\n                    # We can bet? But the rules say we can only check or bet? \n                    # However, in the current game state, if we are the first to act, we can check or bet (which is a bet, but note: the action is CHECK or RAISE? \n                    # Actually, the available actions are: if no bet has been made, we can check or bet (which is a raise? or a bet?).\n                    # The problem says: \n                    #   Actions: Fold, Check, Call, Raise (any amount up to stack, no limit), All-in.\n                    #   But note: if we are first to act in the round, we can check or bet (which is a type of raise? or a separate bet? \n                    #   The state: current_bet is 0? or the current bet is the current high bet? \n                    #   The RoundStateClient has: current_bet: int -> the current bet to call? \n                    #   So if current_bet is 0, then we can check (if we don't want to bet) or we can bet (which is a raise?).\n                    #   The PokerAction RAISE is for betting more than the current_bet. If current_bet is 0, then RAISE becomes a bet of at least min_raise (which is the big blind?).\n                    #   So we can do a bet (raise) of any amount above 0 and at least min_raise? \n\n                    # We'll do a continuation bet if we were the raiser pre-flop? \n                    # But we don't track that. Instead, we can bet if we have a strong hand or a draw? \n                    # We'll bet half the pot if hand_score is strong.\n                    bet_amount = min(round_state.pot // 2, remaining_chips)\n                    if bet_amount >= min_raise:\n                        action = PokerAction.RAISE\n                        amount = bet_amount  # because we haven't put any bet in this round? but note: our_bet might be from previous rounds? \n                        # Actually, in the current round, we haven bet? our_bet is the total we have bet in the hand so far? \n                        # But the current_round: our_bet might be 0? \n                        # The state: player_bets is the total by the player in the hand? or in the round?\n                        # The problem says: player_bets: Dict[str, int] -> Bets by player ID. It doesn't specify per round. \n                        # But the current_round: we are only acting once per round? and the current_bet is the current round's bet?\n                        # We'll assume that our_bet is the amount we have bet in the current hand (including previous rounds). \n                        # But when we bet in the current round, we are adding to our_bet. \n                        # However, the current_round's current_bet might be 0? meaning no one has bet in this round? \n                        # So if we are first to act, we can bet any amount from min_raise to max_raise.\n\n                        # We want to bet an amount that is at least min_raise. We set our bet to min_raise? or half pot? \n                        # But note: the amount we return is the total we are increasing the bet? \n                        # Actually, the RAISE action: we must specify the amount we are raising by? \n                        # The problem says: \"For RAISE: the amount raise combine with your current bet must be larger than the the current raise.\" \n                        # And: \"min_raise: Minimum raise amount\" -> which is the minimum we must raise above the current bet? \n                        # So if current_bet=0, then min_raise might be the big blind? \n                        # We can set: total_bet = min_raise (which is the minimum we can bet) -> so we set amount = min_raise? \n                        # But note: the bot's get_action returns (PokerAction, amount) where the amount is the total amount we are going to add to the pot? \n                        # Or is it the amount we are raising (the additional amount above the current bet)? \n                        # The problem says: \n                        #   \"For RAISE: the amount raise combine with your current bet must be larger than the the current raise.\"\n                        #   And: \"min_raise: Minimum raise amount\" -> so we must raise by at least min_raise? \n                        #   But note: the current_bet is the current highest bet in the round. \n                        #   Example: current_bet=0, then min_raise might be 100 (big blind). Then we must set amount (the total we are going to put) to at least 100? \n                        #   But note: our current bet in the round is 0? so we put 100? \n                        #   The problem says: the amount we return for RAISE is the total we are putting in the pot for that action? \n                        #   Looking at the example: \n                        #       (PokerAction.RAISE, 100) means we are putting 100 chips? and then our total bet in the round becomes 100? \n                        #   But the problem says: \"combine with your current bet\" -> so if we have already bet 50 in the round, then a raise of 100 would make our total 150? \n                        #   However, the state: our_bet (from player_bets) is the total we have bet in the hand (all rounds)? \n                        #   We are confused. \n\n                        # Let's look at the example in the problem: \n                        #   \"For RAISE: the amount raise combine with your current bet must be larger than the the current raise.\"\n                        #   It says \"the current raise\", which might refer to the current highest bet? \n                        #   Actually, the problem says: \"min_raise: Minimum raise amount\" -> which is the minimum we must raise above the current highest bet? \n                        #   So if current_bet is 100, and min_raise is 100, then we must raise to at least 200? \n                        #   Then the amount we return for RAISE should be the total we are going to put? so 200? \n                        #   But note: we might have already put 100? then we only need to put 100 more? \n                        #   However, the state: our_bet is the total we have bet in the hand (across rounds). \n                        #   In the current round, we might have put 0? then we put 200? \n\n                        # We'll assume that the amount we return for RAISE is the total amount we are going to add to the pot for this action? \n                        #   So if we are raising to 200, and we have not bet in the current round, then we return 200? \n                        #   But if we have already bet 50 in the current round, then to raise to 200 we need to put 150 more? \n                        #   However, the state: player_bets is the total in the hand (all rounds). \n                        #   The current_round: the current_bet is the highest bet in the current round? \n                        #   We are not given the breakdown per round. \n\n                        # The RoundStateClient has: player_bets: Dict[str, int] -> total in the hand? \n                        #   and current_bet: int -> the current highest bet in the current round? \n                        #   So the amount we have bet in the current round is: \n                        #       current_round_bet = our_bet - (the sum of our bets in previous rounds) \n                        #   But we don't track that. \n\n                        # Alternatively, note: the current_round: the current_bet is the amount that every player must match to stay? \n                        #   and we (our bot) have already put some amount in the current round? \n                        #   The state: player_bets is the total we have put in the hand? \n                        #   But the current_round: we might have put 0? \n                        #   Actually, the problem says: \"current_bet: The current bet (need to match round's current bet minus your bet if you want to call)\"\n                        #   So: to_call = current_bet - (the amount we have bet in the current round) \n                        #   But note: we don't have the amount we have bet in the current round. \n\n                        # We have: \n                        #   our_bet (from player_bets) is the total in the hand? \n                        #   But the current_round: the current_bet is the current highest bet? \n                        #   How to know how much we have bet in the current round? \n                        #   We don't. \n\n                        # However, note: at the start of the round, we have not bet in the current round? \n                        #   But during the round, we might have already acted? \n                        #   The state: player_actions might show our previous actions? \n                        #   But we don't track that. \n\n                        # Given the complexity, we must assume that the amount we have bet in the current round is: \n                        #   current_round_our_bet = our_bet - (the amount we had at the end of the previous round) \n                        #   But we don't store that. \n\n                        # Alternatively, we can avoid raising if we are not sure? \n                        #   But the problem requires that we return a valid action. \n\n                        # We'll do: \n                        #   If we are raising to X, then the amount we return is X - (the amount we have already put in the current round) \n                        #   But we don't know the amount we have already put in the current round. \n\n                        # However, note: the state: player_bets is the total in the hand? \n                        #   And the current_round: we haven't put any bet in the current round? \n                        #   Actually, the state: the current_round hasn't started? \n                        #   No, we are in the middle of the round? \n\n                        # This is complex. The problem says: \n                        #   \"For RAISE: the amount raise combine with your current bet must be larger than the the current raise.\"\n                        #   We interpret: the total we are putting in the pot for this action (for the raise) must be such that: \n                        #       (our current bet in the round + amount) > current_bet + min_raise\n                        #   But we don't know our current bet in the round. \n\n                        #   Actually, the problem says: \"current_bet: The current bet (need to match round's current bet minus your bet if you want to call)\" \n                        #   So: the amount we have already bet in the current round is: our_bet_in_round = current_bet - to_call? \n                        #   But that doesn't make sense. \n\n                        #   Alternatively, the problem says: \"the amount raise combine with your current bet must be larger than the current raise\"\n                        #   We think: \n                        #       Let current_round_our_bet = the amount we have put in the current round? (which we don't have)\n                        #       Then we require: current_round_our_bet + amount > current_bet + min_raise\n\n                        #   But note: the state: player_bets is the total in the hand? and we don't know how much of that is in the current round. \n\n                        #   We need to store the amount we had at the end of the previous round? \n\n                        #   We'll change our bot: in on_round_start, we store the total bet we had at the start of the round? \n                        #   Then at the current action, our current round bet = our_bet (total hand bet) - self.hole_card_round_start_bet\n                        #   But we haven't done that. \n\n                        #   Given the time, we'll avoid raising in post-flop for now? \n                        #   We'll change: in post-flop, we only call, check, fold, or all-in? \n\n                        #   We'll revert to simpler actions: \n                        #       If we can check, we check.\n                        #       Else if we have a strong hand, we call or all-in? \n                        #       Else fold.\n\n                        #   Let's change the above code for post-flop to not raise? \n                    else:\n                        # We cannot even make the min_raise? then we check? \n                        action = PokerAction.CHECK\n                        amount = 0\n                else:\n                    # Check\n                    action = PokerAction.CHECK\n                    amount = 0\n            else:\n                # There is a current bet that is greater than our current total bet in the round? \n                # We must call, raise, or fold.\n                to_call = current_bet - our_bet   # but note: our_bet is total hand bet? \n                # Actually, the problem says: \"current_bet: The current bet (need to match round's current bet minus your bet if you want to call)\" \n                #   So to_call = current_bet - (our hand bet? or our round bet?) \n                #   The problem says: \"your bet\" -> which is the amount we have bet in the current round? \n                #   But we don't have that. \n                #   We'll use the provided to_call? \n                #   Actually, we are given current_bet and we can get our_bet from player_bets? \n                #   But the player_bets is the total in the hand? \n                #   And the problem says: to_call = current_bet - (our current round bet) \n                #   How to get our current round bet? \n                #   We don't have it. \n\n                #   We'll assume that the provided to_call in the state is the amount we need to call? \n                #   But the RoundStateClient doesn't have a to_call field. \n                #   The problem says: \"current_bet: The current bet\" -> and we are also given player_bets for our bot? \n                #   We'll compute: \n                #       to_call = current_bet - (player_bets[self.id] if self.id is in player_bets else 0)\n                #   But note: the player_bets might be the total in the hand? and the current_bet is the current highest in the round? \n                #   Then the amount we have put in the current round is not given. \n\n                #   This is a design flaw in the state. \n\n                #   Given the ambiguity, we'll use the following from the problem: \n                #       \"current_bet: The current bet (need to match round's current bet minus your bet if you want to call)\"\n                #   So: to_call = current_bet - (our current round bet) \n                #   But we don't have our current round bet. \n\n                #   We'll assume that our current round bet is: \n                #       self.hole_card_round_start_bet -> which we set in on_round_start? \n                #   But we haven't set it. \n\n                #   We'll change: in on_round_start, we store the total hand bet at the start of the round? \n                #   Then during the round, our current round bet = player_bets[self.id] - self.start_of_round_bet\n                #   But we didn't save that. \n\n                #   Given the complexity and token limit, we'll assume that the provided to_call in the state is the amount we need to call? \n                #   But the state does not provide to_call. \n\n                #   We'll compute to_call as: current_bet - (our_bet in the current round) \n                #   But we don't have our_bet in the current round. \n\n                #   We'll avoid this for now and use a different approach: \n                #       We'll only fold, call, or all-in in post-flop. \n                #       For call: we don't need to compute to_call? because the problem says: \"For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call\"\n                #       So if we return (PokerAction.CALL, 0), the amount is automatically computed. \n                #       But the problem says: \"the amount needed to call (current_bet - your bet)\" \n                #       So our_bet here is the amount we have bet in the current round? \n                #       But we don't know it. \n\n                #   However, the server knows it. \n                #   Therefore, when we return CALL, the server will compute the amount needed. \n                #   Similarly, for RAISE, the server will know our current round bet and then enforce that the amount we return makes our total in the round >= current_bet + min_raise. \n                #   But we are not doing RAISE in post-flop. \n\n                #   So we'll do: \n                #       if hand_score >= 0.7:\n                #           action = PokerAction.CALL\n                #           amount = 0   # the amount is computed by the server\n                #       elif hand_score >= 0.5:\n                #           # Pot odds: if the call is small compared to the pot, we call.\n                #           # Estimate to_call: we don't have it, but we can use the current_bet? \n                #           # But note: the amount we have to call might be large, but we don't know. \n                #           # We'll call if the current_bet is not too high? \n                #           if current_bet < round_state.pot * 0.5:   # if the bet is less than half the pot, we call\n                #               action = PokerAction.CALL\n                #               amount = 0\n                #           else:\n                #               action = PokerAction.FOLD\n                #               amount = 0\n                #       else:\n                #           action = PokerAction.FOLD\n                #           amount = 0\n\n                if hand_score >= 0.7:\n                    action = PokerAction.CALL\n                    amount = 0\n                elif hand_score >= 0.5:\n                    # We'll use the provided current_bet and our_bet to estimate to_call? \n                    # But note: the player_bets for us might be the total in the hand? \n                    # And the current_bet is the current highest in the round? \n                    # How much have we put in the current round? \n                    # We don't know. \n                    # We'll assume that the amount we have put in the current round is 0? \n                    # Then to_call = current_bet. \n                    # But that might be wrong. \n                    # Instead, we'll trust the server to compute the call amount for us? \n                    # But we can't because we have to decide. \n                    # We'll fold because we are not sure. \n                    action = PokerAction.FOLD\n                    amount = 0\n                else:\n                    action = PokerAction.FOLD\n                    amount = 0\n\n        # However, we might be in a situation where we are all-in? \n        #   If our_chips is very small, we can go all-in if we have a good hand? \n        #   We don't handle that yet. \n\n        # We'll add: if we are very short-stacked, we can go all-in with a decent hand? \n        if remaining_chips < round_state.pot * 0.3 and hand_score >= 0.6:\n            action = PokerAction.ALL_IN\n            amount = 0\n\n        # Also, if the action we chose is not valid given the current state? \n        #   For example, if we chose but we don't have enough chips? \n        #   We should check: \n        #       if action is PokerAction.RAISE: \n        #           if amount > remaining_chips: then we can't raise that much -> we can either do ALL_IN or CALL if we don't have enough for the raise? \n        #           But note: if we don't have enough for the raise, we can go all-in if it's at least a min_raise? \n        #           However, the problem says: \"all-in\" is available. \n        #       if action is PokerAction.CALL: \n        #           if to_call > remaining_chips: then we can only go all-in or fold? \n        #   We'll adjust: \n        if action == PokerAction.RAISE:\n            if amount > remaining_chips:\n                # We can go all-in? \n                action = PokerAction.ALL_IN\n                amount = 0\n            elif amount < min_raise and amount < remaining_chips:\n                # We cannot make a valid raise? then we can only call or fold? \n                action = PokerAction.CALL\n                amount = 0\n        elif action == PokerAction.CALL:\n            # We need to check if to_call is greater than our remaining chips? \n            # But we don't have to_call. \n            # The server will automatically make us all-in if we call and to_call > remaining_chips? \n            # Or do we have to handle that? \n            # The problem says: \"For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call\"\n            #   So if we don't have enough, it will be an all-in? \n            #   But the problem also says: \"all-in\" is an available action. \n            #   We don't need to change. \n            pass\n\n        return (action, amount)\n\n    def get_hand_key(self, hand: List[str]) -> str:\n        # Convert hand to a key like 'AKs' or 'AKo'\n        # Sort the hand by rank: \n        ranks = ['2','3','4','5','6','7','8','9','T','J','Q','K','A']\n        # Map the hand to ranks: \n        card1, card2 = hand\n        rank1 = card1[0]\n        rank2 = card2[0]\n        suit1 = card1[1]\n        suit2 = card2[1]\n\n        # If rank1 and rank2 are the same, it's a pair.\n        if rank1 == rank2:\n            return rank1 + rank2\n\n        # Sort the two ranks\n        if ranks.index(rank1) > ranks.index(rank2):\n            return rank1 + rank2 + ('s' if suit1 == suit2 else 'o')\n        else:\n            return rank2 + rank1 + ('s' if suit1 == suit2 else 'o')\n\n    def evaluate_hand_strength(self, our_hand: List[str], community_cards: List[str]) -> float:\n        # Combine our hand and community cards.\n        all_cards = our_hand + community_cards\n        # We'll do a very simple hand strength evaluation: \n        #   Check for pairs, two pairs, etc.\n        #   We'll count the number of pairs, and then adjust for high cards.\n\n        # Count the ranks and flush possibilities.\n        ranks = {}\n        suits = {}\n        for card in all_cards:\n            rank = card[0]\n            suit = card[1]\n            ranks[rank] = ranks.get(rank, 0) + 1\n            suits[suit] = suits.get(suit, 0) + 1\n\n        # Check for flush: at least 5 of the same suit? \n        flush = False\n        for suit, count in suits.items():\n            if count >= 5:\n                flush = True\n\n        # Count pairs, three of a kind, etc.\n        counts = sorted(ranks.values(), reverse=True)\n        counts += [0] * (5 - len(counts))  # pad to 5\n\n        # Hand types:\n        if counts[0] == 4:\n            return 0.95\n        elif counts[0] == 3 and counts[1] == 2:\n            return 0.9\n        elif flush:\n            # Check for straight? \n            # We won't check straight for now.\n            return 0.8\n        elif counts[0] == 3:\n            return 0.7\n        elif counts[0] == 2 and counts[1] == 2:\n            return 0.6\n        elif counts[0] == 2:\n            return 0.4\n        else:\n            # High card: we take the highest card.\n            # Map: A=14, K=13, ... 2=2\n            rank_values = {'2':2, '3':3, '4':4, '5':5, '6':6, '7':7, '8':8, '9':9, 'T':10, 'J':11, 'Q':12, 'K':13, 'A':14}\n            max_rank = max(rank_values[card[0]] for card in all_cards)\n            return max_rank / 14.0 * 0.3   # so maximum high card is 0.3\n\n    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):\n        pass\n\n    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):\n        pass\n```\n\nGiven the token constraints, we must keep the code as minimal as possible. We removed complex post-flop hand evaluation and avoided raising in post-flop to reduce complexity and potential errors.\n\nNote: We are aware that the post-flop strategy is very weak, but we hope the pre-flop strategy and the simple post-flop will be enough to avoid errors and perform moderately.\n\nWe also note that we did not implement the side pots and all-in handling in the evaluation, but the server will handle the side pots. Our bot only needs to decide on actions.\n\nWe'll return the above code and an empty requirements.txt (since we didn't use any external libraries beyond the provided ones).\n\nHowever, note: the code might have issues with the to_call in post-flop. We avoided it by not raising and by only folding or calling. The call amount is computed by the server.\n\nLet's hope this reduces the token limit and passes the tests.\n\nRequirements.txt (empty because no external libraries beyond the provided ones):\n\n```text\n```\n\nBut note: we used `random` in the code? Actually, we didn't. We had `import random` but we didn't use it. We can remove it.\n\nRemoved `import random`.\n\nFinal code:"
      }
    }
  ],
  "usage": {
    "prompt_tokens": 2662,
    "completion_tokens": 10782,
    "total_tokens": 13444,
    "prompt_tokens_details": null
  }
}
================================================================================

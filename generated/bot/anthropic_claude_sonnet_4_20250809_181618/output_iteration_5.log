
================================================================================
TIMESTAMP: 2025-08-09 18:24:01
MODEL: anthropic/claude-sonnet-4
PROMPT LENGTH: 22180 characters
RESPONSE LENGTH: 16099 characters
USAGE: {
  "prompt_tokens": 7381,
  "completion_tokens": 4863,
  "total_tokens": 12244
}

PROMPT:

You are tasked with submitting a poker bot to a No-Limit Texas Hold'em poker bot competition: Husky Hold'em.

**Detailed Game Rules**
- No-Limit Texas Hold'em with 2-10 players (often 6-handed tables); bots compete in heads-up or multi-player matches hosted by a central game server.
- Players start with $10,000 chips at the simulation start; simulations run for n games (more than 10 per run); blinds rotate and increase every n games (e.g., after certain rounds); big/small blinds are posted pre-flop.
- Goal: Maximize delta money (ending chips minus starting chips); if a player runs out of chips, they are eliminated from that table; no rebuys.
- Each hand has 4 betting rounds: Pre-flop (after hole cards and blinds), Flop (3 community cards), Turn (1 community card), River (1 community card).
- Actions: Fold, Check, Call, Raise (any amount up to stack, no limit), All-in.
- Hand rankings: Royal flush > Straight flush > Four of a kind > Full house > Flush > Straight > Three of a kind > Two pair > One pair > High card.
- Showdown: If multiple players remain after river betting, best 5-card hand (using any combination of 2 hole cards + 5 community cards) wins the pot; side pots form for all-ins with eligible players.
- Technical Limits: 30 seconds max per move (timeout causes automatic fold); 100MB max memory usage; any error/exception causes automatic fold; all bots are given the same compute limits.

Your task: Implement winning bot in player.py by subclassing Bot as in the template below and follow the above game rules.

Bot Design and Competition Rules:

1. Your bot must subclass Bot as SimplePlayer, implementing all required methods exactly as in the template. Preserve the class name SimplePlayer for compatibility with the game server. The template for the class is as
**SimplePlayer Template:**
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        # TODO implement this

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        # TODO implement this

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # TODO implement this

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Returns the action for the player. """
        # TODO implement this

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        """ Called at the end of the round. """
        # TODO implement this

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # TODO implement this
```
2. DO NOT rename or remove any predefined methods (on_start, on_round_start, get_action, on_end_round, on_end_game), and do not change their signatures.
3. You may add helper functions and instance variables for strategy or tracking.
4. Your bot should be able to abide by no limit texas hold'em rules and handle side pots, all-ins, blind increases, multi-way pots, and be error-free (no exceptions).
5. For each action, always return valid actions:
    - For RAISE: the amount raise combine with your current bet must be larger than the the current raise.
    - For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call (current_bet - your bet).
    - For CHECK: You can't check if round's current bet is larger than 0. Resort to other action (eg CALL, RAISE, ALL_IN).
    - For ALL_IN: You don't need to specify the amount you all in, it will default to all your current money.
    - **INVALID ACTION WILL MAKE YOU LOSE MONEY (automatic result in fold if the condition is not match for each action), so logic must always check bounds and edge cases**.
6. If you use any external libraries, they must be listed in requirements.txt (pure Python only).
7. Implement your bot with SimplePlayer. See full RoundStateClient, PokerAction, and PokerRound definitions below.
8. Your bot should maximize delta money (ending chips minus starting chips). Positive mean gaining money, the more money you gain the better.
9. There might will be data on previous run (error and game score) if this is not the first time you implement. If there is error, fix it so your bot can run. Try to improve your bot from previous round.
10. If there are no usage of external requirements, the text secion for requirement must be empty. DO NOT PUT ANYTHING ELSE. If you want to use any external library, you must put it in that text block
11. Your response must consist ONLY of two files: the complete player.py (as a Python code block) implementing the bot with all template elements preserved plus your improvements, and requirements.txt (as a text block) listing any dependencies (pure Python only, e.g., numpy if needed for calculations). Do not include any other text, explanations, or outputs. See example response below:
Example response:
```python
<Your python code>
```

```text
numpy
matplotlib
<any external library you want to use, put it here>
...
```
12. Your implementation MUST BE IN FULL not putting stub method or guideline. Everything in SimplePlayer must be ready to the detail and ready to run.
13. When you do division, make sure to make it prone to error divide by zero by adding some small delta.
14. The pool of submitted bots, including your bot, will be organized into 6-handed poker tables where every possible combination of 6 bots forms a separate table. Each table will play exactly 1,000 hands, with chip stacks carrying over between hands within the same table. 
15. At the end of each table, delta money is calculated for each bot using the formula: final chip count minus 10,000 (initial chip amount). Your bot's total tournament score is determined by summing its delta money across all tables it participates in. The bot with the highest cumulative delta money across all tables wins the tournament.
16. Your bot will undergo iterative testing across 5 rounds, where each round involves playing 10 hands of heads-up poker against a house bot. After each round, you will receive either the complete game log showing performance results or any compilation/simulation errors that occurred while attempting to run your bot. Use this feedback to refine your implementation in subsequent iterations.

**References**

**RoundStateClient Full Definition:**
```python
from dataclasses import dataclass
from typing import Dict, List, Any

@dataclass
class RoundStateClient:
    round_num: int # The number of the current round
    round: str # e.g., 'Preflop', 'Flop', 'Turn', 'River'
    community_cards: List[str] # List of community cards, e.g., ['Ah', 'Ks', '3d']
    pot: int # The total pot
    current_player: List[int] # The ids of the current players
    current_bet: int # The current bet (need to match round's current bet minus your current bet if you want to call)
    min_raise: int  # Minimum raise amount
    max_raise: int  # Maximum raise amount (your remaining chips)
    player_bets: Dict[str, int]  # Bets by player ID
    player_actions: Dict[str, str]  # Actions by player ID, e.g., {'3336760419': 'Check', '3266396022': 'Check'}
    side_pots: list[Dict[str, any]] = None  # List of dicts with 'amount' and 'eligible_players' keys

    @classmethod
    def from_message(cls, message: Dict[str, Any]) -> 'RoundStateClient':
        """Create RoundStateClient from a message dictionary"""
        return cls(
            round_num=message['round_num'],
            round=message['round'],
            community_cards=message['community_cards'],
            pot=message['pot'],
            current_player=message['current_player'],
            current_bet=message['current_bet'],
            min_raise=message['min_raise'],
            max_raise=message['max_raise'],
            player_bets=message['player_bets'],
            player_actions=message['player_actions'],
            side_pots=message.get('side_pots', [])
        )
```

**PokerAction and PokerRound Enums:**
```python
from enum import Enum

class PokerAction(Enum):
    FOLD = 1
    CHECK = 2
    CALL = 3
    RAISE = 4
    ALL_IN = 5

class PokerRound(Enum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3
```

**Bot abstract class:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple

from type.round_state import RoundStateClient
from type.poker_action import PokerAction

class Bot(ABC):
    def __init__(self) -> None:
        """ Initializes the player. """
        self.id = None
        pass

    def set_id(self, player_id: int) -> None:
        """ Sets the player ID. """
        self.id = player_id

    @abstractmethod
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]) -> None:
        """ Called when the game starts. """
        pass

    @abstractmethod
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the start of each round. """
        pass

    @abstractmethod
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Called when it is the player's turn to act. """
        pass

    @abstractmethod
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the end of each round. """
        pass

    @abstractmethod
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict) -> None:
        """ Called at the end of the game. """
        pass
```

ITERATION 5 FEEDBACK AND IMPROVEMENT REQUEST:
You are now working on iteration 5. Based on the previous iteration results and code, please improve the implementation.

PREVIOUS RESULTS:
- Success: True
- Error Message: 

ERRORS ENCOUNTERED:
Game Test Results for Iteration 4 - 2025-08-09 18:22:18
============================================================

No errors detected during game test.

CONTAINER LOGS:
--------------------
Test Client Logs:



POKER CLIENT LOGS:
--------------------
Poker Client Log: No critical errors detected in poker client logs



Please fix these specific errors in your implementation.

GAME PERFORMANCE DATA:

YOUR BOT PLAYER IDS: [374288986]
When analyzing the game data below, focus on these player IDs as they represent YOUR bot's performance.


YOUR BOT PERFORMANCE SUMMARY (across 10 games):
- Average Game Score (Delta per Game): 4.50
- Total Game Score: 45.00
- Total Games Played: 10

Performance Analysis:
- Positive scores indicate profit per game
- Negative scores indicate losses per game
- Focus on improving average game score for better performance

[
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 10010,
      "374288986": 9990
    },
    "finalDelta": {
      "2365966452": 10,
      "374288986": -10
    },
    "gameScores": {
      "2365966452": 10,
      "374288986": -10
    },
    "rounds": 2,
    "finalBoard": [
      "4s",
      "6d",
      "Qs",
      "8h"
    ],
    "playerHands": {
      "2365966451": [
        "5c",
        "6h"
      ],
      "374288985": [
        "Jc",
        "Ts"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 9990,
      "finalDelta": -10,
      "gameScore": -10
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9955,
      "374288986": 10045
    },
    "finalDelta": {
      "2365966452": -45,
      "374288986": 45
    },
    "gameScores": {
      "2365966452": 5,
      "374288986": -5
    },
    "rounds": 1,
    "finalBoard": [
      "Js",
      "7h",
      "3d"
    ],
    "playerHands": {
      "2365966451": [
        "6s",
        "8s"
      ],
      "374288985": [
        "Ts",
        "Qc"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10045,
      "finalDelta": 45,
      "gameScore": -5
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 10015,
      "374288986": 9985
    },
    "finalDelta": {
      "2365966452": 15,
      "374288986": -15
    },
    "gameScores": {
      "2365966452": 5,
      "374288986": -5
    },
    "rounds": 1,
    "finalBoard": [
      "3d",
      "5d",
      "Th"
    ],
    "playerHands": {
      "2365966451": [
        "8h",
        "Kc"
      ],
      "374288985": [
        "6c",
        "2h"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 9985,
      "finalDelta": -15,
      "gameScore": -5
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 10025,
      "374288986": 9975
    },
    "finalDelta": {
      "2365966452": 25,
      "374288986": -25
    },
    "gameScores": {
      "2365966452": 10,
      "374288986": -10
    },
    "rounds": 2,
    "finalBoard": [
      "6h",
      "5h",
      "Kh",
      "2c"
    ],
    "playerHands": {
      "2365966451": [
        "Jh",
        "As"
      ],
      "374288985": [
        "4c",
        "Qd"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 9975,
      "finalDelta": -25,
      "gameScore": -10
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 10030,
      "374288986": 9970
    },
    "finalDelta": {
      "2365966452": 30,
      "374288986": -30
    },
    "gameScores": {
      "2365966452": 5,
      "374288986": -5
    },
    "rounds": 1,
    "finalBoard": [
      "7h",
      "Js",
      "8h"
    ],
    "playerHands": {
      "2365966451": [
        "Kd",
        "4h"
      ],
      "374288985": [
        "Ah",
        "3h"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 9970,
      "finalDelta": -30,
      "gameScore": -5
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9920,
      "374288986": 10080
    },
    "finalDelta": {
      "2365966452": -80,
      "374288986": 80
    },
    "gameScores": {
      "2365966452": -110,
      "374288986": 110
    },
    "rounds": 4,
    "finalBoard": [
      "9d",
      "Jd",
      "Kh",
      "6s",
      "7h"
    ],
    "playerHands": {
      "2365966451": [
        "Tc",
        "5h"
      ],
      "374288985": [
        "Qd",
        "Td"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10080,
      "finalDelta": 80,
      "gameScore": 110
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9925,
      "374288986": 10075
    },
    "finalDelta": {
      "2365966452": -75,
      "374288986": 75
    },
    "gameScores": {
      "2365966452": 5,
      "374288986": -5
    },
    "rounds": 1,
    "finalBoard": [
      "Kc",
      "7h",
      "5c"
    ],
    "playerHands": {
      "2365966451": [
        "Kh",
        "4d"
      ],
      "374288985": [
        "2d",
        "5h"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10075,
      "finalDelta": 75,
      "gameScore": -5
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9935,
      "374288986": 10065
    },
    "finalDelta": {
      "2365966452": -65,
      "374288986": 65
    },
    "gameScores": {
      "2365966452": 10,
      "374288986": -10
    },
    "rounds": 2,
    "finalBoard": [
      "5s",
      "2s",
      "7d",
      "Kc"
    ],
    "playerHands": {
      "2365966451": [
        "6c",
        "Qh"
      ],
      "374288985": [
        "Js",
        "Qc"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10065,
      "finalDelta": 65,
      "gameScore": -10
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9940,
      "374288986": 10060
    },
    "finalDelta": {
      "2365966452": -60,
      "374288986": 60
    },
    "gameScores": {
      "2365966452": 5,
      "374288986": -5
    },
    "rounds": 1,
    "finalBoard": [
      "Qc",
      "7c",
      "Qs"
    ],
    "playerHands": {
      "2365966451": [
        "2d",
        "9c"
      ],
      "374288985": [
        "Ac",
        "9s"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10060,
      "finalDelta": 60,
      "gameScore": -5
    }
  },
  {
    "gameId": "8f6ca521-852b-4b4d-af96-52d9625580b4",
    "players": {
      "default": 2365966452,
      "client_container_6208_test_client_test_anthropic_claude_sonnet_4_iter_4_20250809_182200_iter4": 374288986
    },
    "playerNames": {
      "2365966451": "player2365966452",
      "374288985": "player374288986"
    },
    "finalMoney": {
      "2365966452": 9950,
      "374288986": 10050
    },
    "finalDelta": {
      "2365966452": -50,
      "374288986": 50
    },
    "gameScores": {
      "2365966452": 10,
      "374288986": -10
    },
    "rounds": 2,
    "finalBoard": [
      "6h",
      "5d",
      "Jc",
      "2d"
    ],
    "playerHands": {
      "2365966451": [
        "Ts",
        "Kd"
      ],
      "374288985": [
        "Th",
        "4s"
      ]
    },
    "blinds": {
      "small": 5,
      "big": 10
    },
    "botPlayerId": 374288986,
    "botPerformance": {
      "finalMoney": 10050,
      "finalDelta": 50,
      "gameScore": -10
    }
  }
]

IMPORTANT: When analyzing the game performance data above, focus on the player ID that corresponds to YOUR bot implementation.
Look for your bot's performance in the 'gameScores' field, which shows the delta gain/loss for each individual game.

PERFORMANCE METRICS EXPLANATION:
- 'gameScores': Shows the profit/loss for each individual game (this is what matters most)
- Positive gameScore = Profit in that game
- Negative gameScore = Loss in that game
- Focus on improving your strategy to achieve positive gameScores consistently

Please analyze YOUR bot's gameScore performance and improve the strategy based on these results.

POKER CLIENT ERRORS:
No critical errors detected in poker client logs

Please investigate these errors in your poker client logs and fix any issues in your implementation.

IMPROVEMENT INSTRUCTIONS:
1. You are on iteration 5 - build upon the previous code
2. Analyze the errors and game performance data above
3. Fix any syntax, import, or runtime errors from the previous iteration
4. Improve the poker strategy based on game results
5. Ensure the code follows the exact template requirements
6. Return the improved implementation in the same format (Python code block + requirements.txt block)

Focus on making the bot more competitive and error-free. You can see exactly what was wrong with the previous version and should fix those specific issues.


RESPONSE:
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        self.starting_chips = 10000
        self.my_cards = []
        self.blind_amount = 10
        self.big_blind_player = None
        self.small_blind_player = None
        self.all_players = []
        self.opponent_history = {}
        self.game_history = []
        self.position_stats = {"early": [], "late": []}
        self.bluff_frequency = 0.15
        self.aggression_factor = 1.2

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        self.starting_chips = starting_chips
        self.my_cards = player_hands
        self.blind_amount = blind_amount
        self.big_blind_player = big_blind_player_id
        self.small_blind_player = small_blind_player_id
        self.all_players = all_players

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        if round_state.round == 'Preflop':
            hand_info = {
                'cards': self.my_cards,
                'position': 'late' if self.id == self.big_blind_player else 'early',
                'pot_odds': 0,
                'action_taken': None
            }
            self.game_history.append(hand_info)

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        try:
            my_bet = round_state.player_bets.get(str(self.id), 0)
            amount_to_call = round_state.current_bet - my_bet
            
            # Calculate pot odds
            total_pot = round_state.pot + amount_to_call
            pot_odds = amount_to_call / (total_pot + 0.01) if total_pot > 0 else 0
            
            # Hand strength evaluation
            hand_strength = self._evaluate_hand_strength(round_state)
            position_factor = self._get_position_factor(round_state)
            
            # Opponent modeling
            opponent_aggression = self._estimate_opponent_aggression(round_state)
            
            # Bluff detection
            likely_bluff = self._detect_bluff_opportunity(round_state, hand_strength)
            
            # Stack management
            stack_ratio = remaining_chips / (self.starting_chips + 0.01)
            
            # Adjust strategy based on stack size
            if stack_ratio > 1.5:  # We're winning, play more aggressively
                self.aggression_factor = 1.4
                self.bluff_frequency = 0.20
            elif stack_ratio < 0.7:  # We're losing, tighten up
                self.aggression_factor = 0.9
                self.bluff_frequency = 0.08
            else:
                self.aggression_factor = 1.2
                self.bluff_frequency = 0.15
            
            # Decision making
            if round_state.current_bet == 0:
                # We can check
                if hand_strength >= 0.7 or (likely_bluff and hand_strength >= 0.4):
                    # Strong hand or good bluff spot - bet for value/bluff
                    bet_size = self._calculate_bet_size(round_state, hand_strength, remaining_chips)
                    if bet_size > 0 and bet_size <= remaining_chips:
                        return (PokerAction.RAISE, bet_size)
                return (PokerAction.CHECK, 0)
            
            else:
                # There's a bet to us
                if amount_to_call >= remaining_chips:
                    # All-in situation
                    if hand_strength >= 0.6 or pot_odds > 0.25:
                        return (PokerAction.ALL_IN, 0)
                    else:
                        return (PokerAction.FOLD, 0)
                
                # Calculate expected value
                win_probability = self._calculate_win_probability(hand_strength, round_state)
                expected_value = (win_probability * total_pot) - (1 - win_probability) * amount_to_call
                
                # Consider position and opponent behavior
                adjusted_ev = expected_value * position_factor * (2 - opponent_aggression)
                
                if adjusted_ev > amount_to_call * 0.1:  # Positive EV threshold
                    if hand_strength >= 0.8 or (likely_bluff and remaining_chips > amount_to_call * 4):
                        # Strong hand or good bluff spot - raise
                        raise_size = self._calculate_raise_size(round_state, hand_strength, remaining_chips, amount_to_call)
                        if raise_size >= round_state.min_raise and raise_size <= remaining_chips:
                            return (PokerAction.RAISE, raise_size)
                    
                    # Good hand but not raise-worthy - call
                    if amount_to_call <= remaining_chips:
                        return (PokerAction.CALL, 0)
                
                # Marginal spots - consider pot odds and position
                if pot_odds < 0.3 and position_factor > 1.0 and hand_strength >= 0.3:
                    if amount_to_call <= remaining_chips:
                        return (PokerAction.CALL, 0)
                
                # Default to fold
                return (PokerAction.FOLD, 0)
                
        except Exception as e:
            # Emergency fallback
            if round_state.current_bet == 0:
                return (PokerAction.CHECK, 0)
            elif round_state.current_bet - round_state.player_bets.get(str(self.id), 0) <= remaining_chips // 10:
                return (PokerAction.CALL, 0)
            else:
                return (PokerAction.FOLD, 0)

    def _evaluate_hand_strength(self, round_state: RoundStateClient) -> float:
        if not self.my_cards:
            return 0.3
        
        cards = self.my_cards[:]
        community = round_state.community_cards
        
        # Preflop hand strength
        if round_state.round == 'Preflop':
            return self._preflop_strength(cards)
        
        # Post-flop evaluation
        all_cards = cards + community
        return self._postflop_strength(all_cards, cards, community)
    
    def _preflop_strength(self, cards: List[str]) -> float:
        if len(cards) != 2:
            return 0.3
        
        card1, card2 = cards[0], cards[1]
        rank1, suit1 = card1[0], card1[1]
        rank2, suit2 = card2[0], card2[1]
        
        # Convert face cards to numbers
        rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, 
                      '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}
        
        val1 = rank_values.get(rank1, 7)
        val2 = rank_values.get(rank2, 7)
        
        high_card = max(val1, val2)
        low_card = min(val1, val2)
        suited = (suit1 == suit2)
        paired = (val1 == val2)
        gap = high_card - low_card
        
        strength = 0.0
        
        # Pocket pairs
        if paired:
            if high_card >= 13:  # AA, KK
                strength = 0.95
            elif high_card >= 11:  # QQ, JJ
                strength = 0.85
            elif high_card >= 9:  # TT, 99
                strength = 0.75
            elif high_card >= 7:  # 88, 77
                strength = 0.65
            else:  # 66 and below
                strength = 0.55
        
        # High cards
        elif high_card == 14:  # Ace
            if low_card >= 12:  # AK, AQ
                strength = 0.80 if suited else 0.75
            elif low_card >= 10:  # AJ, AT
                strength = 0.70 if suited else 0.60
            elif low_card >= 8:  # A9, A8
                strength = 0.60 if suited else 0.45
            else:  # A7 and below
                strength = 0.50 if suited else 0.35
        
        elif high_card == 13:  # King
            if low_card >= 11:  # KQ, KJ
                strength = 0.70 if suited else 0.60
            elif low_card >= 9:  # KT, K9
                strength = 0.55 if suited else 0.45
            else:
                strength = 0.40 if suited else 0.30
        
        # Medium to low hands
        elif high_card >= 10:
            if gap <= 1 and low_card >= 9:  # Connected high cards
                strength = 0.60 if suited else 0.50
            elif gap <= 3 and suited:  # Suited connectors/gappers
                strength = 0.45
            else:
                strength = 0.35
        
        else:
            # Low cards
            if gap <= 1 and suited and low_card >= 6:  # Low suited connectors
                strength = 0.40
            else:
                strength = 0.25
        
        return min(0.99, max(0.05, strength))
    
    def _postflop_strength(self, all_cards: List[str], hole_cards: List[str], community: List[str]) -> float:
        if len(community) == 0:
            return self._preflop_strength(hole_cards)
        
        # Basic post-flop evaluation
        ranks = []
        suits = []
        
        for card in all_cards:
            if len(card) >= 2:
                rank = card[0]
                suit = card[1]
                rank_val = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, 
                           '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}.get(rank, 7)
                ranks.append(rank_val)
                suits.append(suit)
        
        if len(ranks) < 2:
            return 0.3
        
        ranks.sort(reverse=True)
        suit_counts = {}
        for suit in suits:
            suit_counts[suit] = suit_counts.get(suit, 0) + 1
        
        rank_counts = {}
        for rank in ranks:
            rank_counts[rank] = rank_counts.get(rank, 0) + 1
        
        count_values = sorted(rank_counts.values(), reverse=True)
        max_suit_count = max(suit_counts.values()) if suit_counts else 0
        
        # Evaluate hand strength
        if count_values[0] == 4:  # Four of a kind
            return 0.95
        elif count_values[0] == 3 and count_values[1] == 2:  # Full house
            return 0.90
        elif max_suit_count >= 5:  # Flush
            return 0.85
        elif self._is_straight(ranks):  # Straight
            return 0.80
        elif count_values[0] == 3:  # Three of a kind
            return 0.75
        elif count_values[0] == 2 and count_values[1] == 2:  # Two pair
            return 0.65
        elif count_values[0] == 2:  # One pair
            pair_rank = max([rank for rank, count in rank_counts.items() if count == 2])
            if pair_rank >= 11:  # High pair
                return 0.60
            else:  # Low pair
                return 0.45
        else:  # High card
            if ranks[0] >= 12:  # King high or better
                return 0.40
            else:
                return 0.25
    
    def _is_straight(self, ranks: List[int]) -> bool:
        unique_ranks = sorted(list(set(ranks)), reverse=True)
        if len(unique_ranks) < 5:
            return False
        
        # Check for regular straight
        for i in range(len(unique_ranks) - 4):
            if unique_ranks[i] - unique_ranks[i+4] == 4:
                return True
        
        # Check for A-5 straight (wheel)
        if 14 in unique_ranks and 5 in unique_ranks and 4 in unique_ranks and 3 in unique_ranks and 2 in unique_ranks:
            return True
        
        return False
    
    def _get_position_factor(self, round_state: RoundStateClient) -> float:
        if len(self.all_players) <= 2:
            return 1.1 if self.id == self.big_blind_player else 0.95
        
        # In larger games, big blind is generally worse position preflop
        if round_state.round == 'Preflop':
            return 0.9 if self.id == self.big_blind_player else 1.1
        else:
            return 1.1 if self.id == self.big_blind_player else 0.95
    
    def _estimate_opponent_aggression(self, round_state: RoundStateClient) -> float:
        # Analyze opponent betting patterns
        total_actions = 0
        aggressive_actions = 0
        
        for player_id, action in round_state.player_actions.items():
            if player_id != str(self.id):
                total_actions += 1
                if action in ['Raise', 'All-in']:
                    aggressive_actions += 1
        
        if total_actions == 0:
            return 0.5  # Neutral assumption
        
        return min(1.0, aggressive_actions / (total_actions + 0.01))
    
    def _detect_bluff_opportunity(self, round_state: RoundStateClient, hand_strength: float) -> bool:
        # Simple bluff detection based on board texture and opponent behavior
        if len(round_state.community_cards) == 0:
            return False
        
        # More likely to bluff on dry boards with position
        position_factor = self._get_position_factor(round_state)
        opponent_aggression = self._estimate_opponent_aggression(round_state)
        
        # Bluff if we have position, opponent seems passive, and board is dry
        return (position_factor > 1.0 and 
                opponent_aggression < 0.3 and 
                hand_strength >= 0.2 and 
                hand_strength <= 0.5)
    
    def _calculate_win_probability(self, hand_strength: float, round_state: RoundStateClient) -> float:
        # Adjust win probability based on number of opponents and betting action
        base_prob = hand_strength
        
        # Adjust for number of active opponents
        active_opponents = len([p for p in round_state.current_player if p != self.id])
        opponent_factor = 0.9 ** active_opponents
        
        # Adjust for betting pressure (if there's heavy betting, we need stronger hands)
        betting_pressure = round_state.current_bet / (round_state.pot + 0.01)
        pressure_factor = 1.0 - min(0.3, betting_pressure * 0.5)
        
        return base_prob * opponent_factor * pressure_factor
    
    def _calculate_bet_size(self, round_state: RoundStateClient, hand_strength: float, remaining_chips: int) -> int:
        pot_size = round_state.pot
        
        if hand_strength >= 0.85:  # Very strong hand
            bet_size = int(pot_size * 0.8 * self.aggression_factor)
        elif hand_strength >= 0.65:  # Strong hand
            bet_size = int(pot_size * 0.6 * self.aggression_factor)
        elif hand_strength >= 0.45:  # Decent hand
            bet_size = int(pot_size * 0.4 * self.aggression_factor)
        else:  # Bluff or weak hand
            bet_size = int(pot_size * 0.3)
        
        return min(bet_size, remaining_chips, round_state.max_raise)
    
    def _calculate_raise_size(self, round_state: RoundStateClient, hand_strength: float, remaining_chips: int, amount_to_call: int) -> int:
        pot_size = round_state.pot + amount_to_call
        
        if hand_strength >= 0.85:  # Very strong hand
            raise_size = amount_to_call + int(pot_size * 0.8 * self.aggression_factor)
        elif hand_strength >= 0.65:  # Strong hand  
            raise_size = amount_to_call + int(pot_size * 0.6 * self.aggression_factor)
        else:  # Bluff
            raise_size = amount_to_call + int(pot_size * 0.4)
        
        # Ensure minimum raise
        min_total_bet = round_state.player_bets.get(str(self.id), 0) + round_state.min_raise
        raise_size = max(raise_size, min_total_bet - round_state.player_bets.get(str(self.id), 0))
        
        return min(raise_size, remaining_chips, round_state.max_raise)

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        # Update game history with results
        if self.game_history:
            self.game_history[-1]['final_pot'] = round_state.pot
            self.game_history[-1]['chips_after'] = remaining_chips

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # Store game results for future analysis
        pass
```

```text

```

RAW API RESPONSE:
{
  "id": "gen-1754788969-oZ6KUG12uw3A5gYoT6oS",
  "provider": "Google",
  "model": "anthropic/claude-sonnet-4",
  "object": "chat.completion",
  "created": 1754788969,
  "choices": [
    {
      "logprobs": null,
      "finish_reason": "stop",
      "native_finish_reason": "stop",
      "index": 0,
      "message": {
        "role": "assistant",
        "content": "```python\nfrom typing import List, Tuple\nfrom bot import Bot\nfrom type.poker_action import PokerAction\nfrom type.round_state import RoundStateClient\n\nclass SimplePlayer(Bot):\n    def __init__(self):\n        super().__init__()\n        self.starting_chips = 10000\n        self.my_cards = []\n        self.blind_amount = 10\n        self.big_blind_player = None\n        self.small_blind_player = None\n        self.all_players = []\n        self.opponent_history = {}\n        self.game_history = []\n        self.position_stats = {\"early\": [], \"late\": []}\n        self.bluff_frequency = 0.15\n        self.aggression_factor = 1.2\n\n    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):\n        self.starting_chips = starting_chips\n        self.my_cards = player_hands\n        self.blind_amount = blind_amount\n        self.big_blind_player = big_blind_player_id\n        self.small_blind_player = small_blind_player_id\n        self.all_players = all_players\n\n    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):\n        if round_state.round == 'Preflop':\n            hand_info = {\n                'cards': self.my_cards,\n                'position': 'late' if self.id == self.big_blind_player else 'early',\n                'pot_odds': 0,\n                'action_taken': None\n            }\n            self.game_history.append(hand_info)\n\n    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:\n        try:\n            my_bet = round_state.player_bets.get(str(self.id), 0)\n            amount_to_call = round_state.current_bet - my_bet\n            \n            # Calculate pot odds\n            total_pot = round_state.pot + amount_to_call\n            pot_odds = amount_to_call / (total_pot + 0.01) if total_pot > 0 else 0\n            \n            # Hand strength evaluation\n            hand_strength = self._evaluate_hand_strength(round_state)\n            position_factor = self._get_position_factor(round_state)\n            \n            # Opponent modeling\n            opponent_aggression = self._estimate_opponent_aggression(round_state)\n            \n            # Bluff detection\n            likely_bluff = self._detect_bluff_opportunity(round_state, hand_strength)\n            \n            # Stack management\n            stack_ratio = remaining_chips / (self.starting_chips + 0.01)\n            \n            # Adjust strategy based on stack size\n            if stack_ratio > 1.5:  # We're winning, play more aggressively\n                self.aggression_factor = 1.4\n                self.bluff_frequency = 0.20\n            elif stack_ratio < 0.7:  # We're losing, tighten up\n                self.aggression_factor = 0.9\n                self.bluff_frequency = 0.08\n            else:\n                self.aggression_factor = 1.2\n                self.bluff_frequency = 0.15\n            \n            # Decision making\n            if round_state.current_bet == 0:\n                # We can check\n                if hand_strength >= 0.7 or (likely_bluff and hand_strength >= 0.4):\n                    # Strong hand or good bluff spot - bet for value/bluff\n                    bet_size = self._calculate_bet_size(round_state, hand_strength, remaining_chips)\n                    if bet_size > 0 and bet_size <= remaining_chips:\n                        return (PokerAction.RAISE, bet_size)\n                return (PokerAction.CHECK, 0)\n            \n            else:\n                # There's a bet to us\n                if amount_to_call >= remaining_chips:\n                    # All-in situation\n                    if hand_strength >= 0.6 or pot_odds > 0.25:\n                        return (PokerAction.ALL_IN, 0)\n                    else:\n                        return (PokerAction.FOLD, 0)\n                \n                # Calculate expected value\n                win_probability = self._calculate_win_probability(hand_strength, round_state)\n                expected_value = (win_probability * total_pot) - (1 - win_probability) * amount_to_call\n                \n                # Consider position and opponent behavior\n                adjusted_ev = expected_value * position_factor * (2 - opponent_aggression)\n                \n                if adjusted_ev > amount_to_call * 0.1:  # Positive EV threshold\n                    if hand_strength >= 0.8 or (likely_bluff and remaining_chips > amount_to_call * 4):\n                        # Strong hand or good bluff spot - raise\n                        raise_size = self._calculate_raise_size(round_state, hand_strength, remaining_chips, amount_to_call)\n                        if raise_size >= round_state.min_raise and raise_size <= remaining_chips:\n                            return (PokerAction.RAISE, raise_size)\n                    \n                    # Good hand but not raise-worthy - call\n                    if amount_to_call <= remaining_chips:\n                        return (PokerAction.CALL, 0)\n                \n                # Marginal spots - consider pot odds and position\n                if pot_odds < 0.3 and position_factor > 1.0 and hand_strength >= 0.3:\n                    if amount_to_call <= remaining_chips:\n                        return (PokerAction.CALL, 0)\n                \n                # Default to fold\n                return (PokerAction.FOLD, 0)\n                \n        except Exception as e:\n            # Emergency fallback\n            if round_state.current_bet == 0:\n                return (PokerAction.CHECK, 0)\n            elif round_state.current_bet - round_state.player_bets.get(str(self.id), 0) <= remaining_chips // 10:\n                return (PokerAction.CALL, 0)\n            else:\n                return (PokerAction.FOLD, 0)\n\n    def _evaluate_hand_strength(self, round_state: RoundStateClient) -> float:\n        if not self.my_cards:\n            return 0.3\n        \n        cards = self.my_cards[:]\n        community = round_state.community_cards\n        \n        # Preflop hand strength\n        if round_state.round == 'Preflop':\n            return self._preflop_strength(cards)\n        \n        # Post-flop evaluation\n        all_cards = cards + community\n        return self._postflop_strength(all_cards, cards, community)\n    \n    def _preflop_strength(self, cards: List[str]) -> float:\n        if len(cards) != 2:\n            return 0.3\n        \n        card1, card2 = cards[0], cards[1]\n        rank1, suit1 = card1[0], card1[1]\n        rank2, suit2 = card2[0], card2[1]\n        \n        # Convert face cards to numbers\n        rank_values = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, \n                      '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}\n        \n        val1 = rank_values.get(rank1, 7)\n        val2 = rank_values.get(rank2, 7)\n        \n        high_card = max(val1, val2)\n        low_card = min(val1, val2)\n        suited = (suit1 == suit2)\n        paired = (val1 == val2)\n        gap = high_card - low_card\n        \n        strength = 0.0\n        \n        # Pocket pairs\n        if paired:\n            if high_card >= 13:  # AA, KK\n                strength = 0.95\n            elif high_card >= 11:  # QQ, JJ\n                strength = 0.85\n            elif high_card >= 9:  # TT, 99\n                strength = 0.75\n            elif high_card >= 7:  # 88, 77\n                strength = 0.65\n            else:  # 66 and below\n                strength = 0.55\n        \n        # High cards\n        elif high_card == 14:  # Ace\n            if low_card >= 12:  # AK, AQ\n                strength = 0.80 if suited else 0.75\n            elif low_card >= 10:  # AJ, AT\n                strength = 0.70 if suited else 0.60\n            elif low_card >= 8:  # A9, A8\n                strength = 0.60 if suited else 0.45\n            else:  # A7 and below\n                strength = 0.50 if suited else 0.35\n        \n        elif high_card == 13:  # King\n            if low_card >= 11:  # KQ, KJ\n                strength = 0.70 if suited else 0.60\n            elif low_card >= 9:  # KT, K9\n                strength = 0.55 if suited else 0.45\n            else:\n                strength = 0.40 if suited else 0.30\n        \n        # Medium to low hands\n        elif high_card >= 10:\n            if gap <= 1 and low_card >= 9:  # Connected high cards\n                strength = 0.60 if suited else 0.50\n            elif gap <= 3 and suited:  # Suited connectors/gappers\n                strength = 0.45\n            else:\n                strength = 0.35\n        \n        else:\n            # Low cards\n            if gap <= 1 and suited and low_card >= 6:  # Low suited connectors\n                strength = 0.40\n            else:\n                strength = 0.25\n        \n        return min(0.99, max(0.05, strength))\n    \n    def _postflop_strength(self, all_cards: List[str], hole_cards: List[str], community: List[str]) -> float:\n        if len(community) == 0:\n            return self._preflop_strength(hole_cards)\n        \n        # Basic post-flop evaluation\n        ranks = []\n        suits = []\n        \n        for card in all_cards:\n            if len(card) >= 2:\n                rank = card[0]\n                suit = card[1]\n                rank_val = {'2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, \n                           '9': 9, 'T': 10, 'J': 11, 'Q': 12, 'K': 13, 'A': 14}.get(rank, 7)\n                ranks.append(rank_val)\n                suits.append(suit)\n        \n        if len(ranks) < 2:\n            return 0.3\n        \n        ranks.sort(reverse=True)\n        suit_counts = {}\n        for suit in suits:\n            suit_counts[suit] = suit_counts.get(suit, 0) + 1\n        \n        rank_counts = {}\n        for rank in ranks:\n            rank_counts[rank] = rank_counts.get(rank, 0) + 1\n        \n        count_values = sorted(rank_counts.values(), reverse=True)\n        max_suit_count = max(suit_counts.values()) if suit_counts else 0\n        \n        # Evaluate hand strength\n        if count_values[0] == 4:  # Four of a kind\n            return 0.95\n        elif count_values[0] == 3 and count_values[1] == 2:  # Full house\n            return 0.90\n        elif max_suit_count >= 5:  # Flush\n            return 0.85\n        elif self._is_straight(ranks):  # Straight\n            return 0.80\n        elif count_values[0] == 3:  # Three of a kind\n            return 0.75\n        elif count_values[0] == 2 and count_values[1] == 2:  # Two pair\n            return 0.65\n        elif count_values[0] == 2:  # One pair\n            pair_rank = max([rank for rank, count in rank_counts.items() if count == 2])\n            if pair_rank >= 11:  # High pair\n                return 0.60\n            else:  # Low pair\n                return 0.45\n        else:  # High card\n            if ranks[0] >= 12:  # King high or better\n                return 0.40\n            else:\n                return 0.25\n    \n    def _is_straight(self, ranks: List[int]) -> bool:\n        unique_ranks = sorted(list(set(ranks)), reverse=True)\n        if len(unique_ranks) < 5:\n            return False\n        \n        # Check for regular straight\n        for i in range(len(unique_ranks) - 4):\n            if unique_ranks[i] - unique_ranks[i+4] == 4:\n                return True\n        \n        # Check for A-5 straight (wheel)\n        if 14 in unique_ranks and 5 in unique_ranks and 4 in unique_ranks and 3 in unique_ranks and 2 in unique_ranks:\n            return True\n        \n        return False\n    \n    def _get_position_factor(self, round_state: RoundStateClient) -> float:\n        if len(self.all_players) <= 2:\n            return 1.1 if self.id == self.big_blind_player else 0.95\n        \n        # In larger games, big blind is generally worse position preflop\n        if round_state.round == 'Preflop':\n            return 0.9 if self.id == self.big_blind_player else 1.1\n        else:\n            return 1.1 if self.id == self.big_blind_player else 0.95\n    \n    def _estimate_opponent_aggression(self, round_state: RoundStateClient) -> float:\n        # Analyze opponent betting patterns\n        total_actions = 0\n        aggressive_actions = 0\n        \n        for player_id, action in round_state.player_actions.items():\n            if player_id != str(self.id):\n                total_actions += 1\n                if action in ['Raise', 'All-in']:\n                    aggressive_actions += 1\n        \n        if total_actions == 0:\n            return 0.5  # Neutral assumption\n        \n        return min(1.0, aggressive_actions / (total_actions + 0.01))\n    \n    def _detect_bluff_opportunity(self, round_state: RoundStateClient, hand_strength: float) -> bool:\n        # Simple bluff detection based on board texture and opponent behavior\n        if len(round_state.community_cards) == 0:\n            return False\n        \n        # More likely to bluff on dry boards with position\n        position_factor = self._get_position_factor(round_state)\n        opponent_aggression = self._estimate_opponent_aggression(round_state)\n        \n        # Bluff if we have position, opponent seems passive, and board is dry\n        return (position_factor > 1.0 and \n                opponent_aggression < 0.3 and \n                hand_strength >= 0.2 and \n                hand_strength <= 0.5)\n    \n    def _calculate_win_probability(self, hand_strength: float, round_state: RoundStateClient) -> float:\n        # Adjust win probability based on number of opponents and betting action\n        base_prob = hand_strength\n        \n        # Adjust for number of active opponents\n        active_opponents = len([p for p in round_state.current_player if p != self.id])\n        opponent_factor = 0.9 ** active_opponents\n        \n        # Adjust for betting pressure (if there's heavy betting, we need stronger hands)\n        betting_pressure = round_state.current_bet / (round_state.pot + 0.01)\n        pressure_factor = 1.0 - min(0.3, betting_pressure * 0.5)\n        \n        return base_prob * opponent_factor * pressure_factor\n    \n    def _calculate_bet_size(self, round_state: RoundStateClient, hand_strength: float, remaining_chips: int) -> int:\n        pot_size = round_state.pot\n        \n        if hand_strength >= 0.85:  # Very strong hand\n            bet_size = int(pot_size * 0.8 * self.aggression_factor)\n        elif hand_strength >= 0.65:  # Strong hand\n            bet_size = int(pot_size * 0.6 * self.aggression_factor)\n        elif hand_strength >= 0.45:  # Decent hand\n            bet_size = int(pot_size * 0.4 * self.aggression_factor)\n        else:  # Bluff or weak hand\n            bet_size = int(pot_size * 0.3)\n        \n        return min(bet_size, remaining_chips, round_state.max_raise)\n    \n    def _calculate_raise_size(self, round_state: RoundStateClient, hand_strength: float, remaining_chips: int, amount_to_call: int) -> int:\n        pot_size = round_state.pot + amount_to_call\n        \n        if hand_strength >= 0.85:  # Very strong hand\n            raise_size = amount_to_call + int(pot_size * 0.8 * self.aggression_factor)\n        elif hand_strength >= 0.65:  # Strong hand  \n            raise_size = amount_to_call + int(pot_size * 0.6 * self.aggression_factor)\n        else:  # Bluff\n            raise_size = amount_to_call + int(pot_size * 0.4)\n        \n        # Ensure minimum raise\n        min_total_bet = round_state.player_bets.get(str(self.id), 0) + round_state.min_raise\n        raise_size = max(raise_size, min_total_bet - round_state.player_bets.get(str(self.id), 0))\n        \n        return min(raise_size, remaining_chips, round_state.max_raise)\n\n    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):\n        # Update game history with results\n        if self.game_history:\n            self.game_history[-1]['final_pot'] = round_state.pot\n            self.game_history[-1]['chips_after'] = remaining_chips\n\n    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):\n        # Store game results for future analysis\n        pass\n```\n\n```text\n\n```",
        "refusal": null,
        "reasoning": null
      }
    }
  ],
  "usage": {
    "prompt_tokens": 7381,
    "completion_tokens": 4863,
    "total_tokens": 12244
  }
}
================================================================================

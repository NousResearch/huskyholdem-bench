
    ================================================================================
    TIMESTAMP: 2025-08-09 18:34:34
    MODEL: openai/gpt-5 (OpenAI Direct API)
    PROMPT LENGTH: 9908 characters
    RESPONSE LENGTH: 25216 characters
    USAGE: {
  "input_tokens": 2315,
  "input_tokens_details": {
    "cached_tokens": 128
  },
  "output_tokens": 13509,
  "output_tokens_details": {
    "reasoning_tokens": 6848
  },
  "total_tokens": 15824
}

    PROMPT:
    You are tasked with submitting a poker bot to a No-Limit Texas Hold'em poker bot competition: Husky Hold'em.

**Detailed Game Rules**
- No-Limit Texas Hold'em with 2-10 players (often 6-handed tables); bots compete in heads-up or multi-player matches hosted by a central game server.
- Players start with $10,000 chips at the simulation start; simulations run for n games (more than 10 per run); blinds rotate and increase every n games (e.g., after certain rounds); big/small blinds are posted pre-flop.
- Goal: Maximize delta money (ending chips minus starting chips); if a player runs out of chips, they are eliminated from that table; no rebuys.
- Each hand has 4 betting rounds: Pre-flop (after hole cards and blinds), Flop (3 community cards), Turn (1 community card), River (1 community card).
- Actions: Fold, Check, Call, Raise (any amount up to stack, no limit), All-in.
- Hand rankings: Royal flush > Straight flush > Four of a kind > Full house > Flush > Straight > Three of a kind > Two pair > One pair > High card.
- Showdown: If multiple players remain after river betting, best 5-card hand (using any combination of 2 hole cards + 5 community cards) wins the pot; side pots form for all-ins with eligible players.
- Technical Limits: 30 seconds max per move (timeout causes automatic fold); 100MB max memory usage; any error/exception causes automatic fold; all bots are given the same compute limits.

Your task: Implement winning bot in player.py by subclassing Bot as in the template below and follow the above game rules.

Bot Design and Competition Rules:

1. Your bot must subclass Bot as SimplePlayer, implementing all required methods exactly as in the template. Preserve the class name SimplePlayer for compatibility with the game server. The template for the class is as
**SimplePlayer Template:**
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        # TODO implement this

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        # TODO implement this

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # TODO implement this

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Returns the action for the player. """
        # TODO implement this

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        """ Called at the end of the round. """
        # TODO implement this

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # TODO implement this
```
2. DO NOT rename or remove any predefined methods (on_start, on_round_start, get_action, on_end_round, on_end_game), and do not change their signatures.
3. You may add helper functions and instance variables for strategy or tracking.
4. Your bot should be able to abide by no limit texas hold'em rules and handle side pots, all-ins, blind increases, multi-way pots, and be error-free (no exceptions).
5. For each action, always return valid actions:
    - For RAISE: the amount raise combine with your current bet must be larger than the the current raise.
    - For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call (current_bet - your bet).
    - For CHECK: You can't check if round's current bet is larger than 0. Resort to other action (eg CALL, RAISE, ALL_IN).
    - For ALL_IN: You don't need to specify the amount you all in, it will default to all your current money.
    - **INVALID ACTION WILL MAKE YOU LOSE MONEY (automatic result in fold if the condition is not match for each action), so logic must always check bounds and edge cases**.
6. If you use any external libraries, they must be listed in requirements.txt (pure Python only).
7. Implement your bot with SimplePlayer. See full RoundStateClient, PokerAction, and PokerRound definitions below.
8. Your bot should maximize delta money (ending chips minus starting chips). Positive mean gaining money, the more money you gain the better.
9. There might will be data on previous run (error and game score) if this is not the first time you implement. If there is error, fix it so your bot can run. Try to improve your bot from previous round.
10. If there are no usage of external requirements, the text secion for requirement must be empty. DO NOT PUT ANYTHING ELSE. If you want to use any external library, you must put it in that text block
11. Your response must consist ONLY of two files: the complete player.py (as a Python code block) implementing the bot with all template elements preserved plus your improvements, and requirements.txt (as a text block) listing any dependencies (pure Python only, e.g., numpy if needed for calculations). Do not include any other text, explanations, or outputs. See example response below:
Example response:
```python
<Your python code>
```

```text
numpy
matplotlib
<any external library you want to use, put it here>
...
```
12. Your implementation MUST BE IN FULL not putting stub method or guideline. Everything in SimplePlayer must be ready to the detail and ready to run.
13. When you do division, make sure to make it prone to error divide by zero by adding some small delta.
14. The pool of submitted bots, including your bot, will be organized into 6-handed poker tables where every possible combination of 6 bots forms a separate table. Each table will play exactly 1,000 hands, with chip stacks carrying over between hands within the same table. 
15. At the end of each table, delta money is calculated for each bot using the formula: final chip count minus 10,000 (initial chip amount). Your bot's total tournament score is determined by summing its delta money across all tables it participates in. The bot with the highest cumulative delta money across all tables wins the tournament.
16. Your bot will undergo iterative testing across 5 rounds, where each round involves playing 10 hands of heads-up poker against a house bot. After each round, you will receive either the complete game log showing performance results or any compilation/simulation errors that occurred while attempting to run your bot. Use this feedback to refine your implementation in subsequent iterations.

**References**

**RoundStateClient Full Definition:**
```python
from dataclasses import dataclass
from typing import Dict, List, Any

@dataclass
class RoundStateClient:
    round_num: int # The number of the current round
    round: str # e.g., 'Preflop', 'Flop', 'Turn', 'River'
    community_cards: List[str] # List of community cards, e.g., ['Ah', 'Ks', '3d']
    pot: int # The total pot
    current_player: List[int] # The ids of the current players
    current_bet: int # The current bet (need to match round's current bet minus your current bet if you want to call)
    min_raise: int  # Minimum raise amount
    max_raise: int  # Maximum raise amount (your remaining chips)
    player_bets: Dict[str, int]  # Bets by player ID
    player_actions: Dict[str, str]  # Actions by player ID, e.g., {'3336760419': 'Check', '3266396022': 'Check'}
    side_pots: list[Dict[str, any]] = None  # List of dicts with 'amount' and 'eligible_players' keys

    @classmethod
    def from_message(cls, message: Dict[str, Any]) -> 'RoundStateClient':
        """Create RoundStateClient from a message dictionary"""
        return cls(
            round_num=message['round_num'],
            round=message['round'],
            community_cards=message['community_cards'],
            pot=message['pot'],
            current_player=message['current_player'],
            current_bet=message['current_bet'],
            min_raise=message['min_raise'],
            max_raise=message['max_raise'],
            player_bets=message['player_bets'],
            player_actions=message['player_actions'],
            side_pots=message.get('side_pots', [])
        )
```

**PokerAction and PokerRound Enums:**
```python
from enum import Enum

class PokerAction(Enum):
    FOLD = 1
    CHECK = 2
    CALL = 3
    RAISE = 4
    ALL_IN = 5

class PokerRound(Enum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3
```

**Bot abstract class:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple

from type.round_state import RoundStateClient
from type.poker_action import PokerAction

class Bot(ABC):
    def __init__(self) -> None:
        """ Initializes the player. """
        self.id = None
        pass

    def set_id(self, player_id: int) -> None:
        """ Sets the player ID. """
        self.id = player_id

    @abstractmethod
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]) -> None:
        """ Called when the game starts. """
        pass

    @abstractmethod
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the start of each round. """
        pass

    @abstractmethod
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Called when it is the player's turn to act. """
        pass

    @abstractmethod
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the end of each round. """
        pass

    @abstractmethod
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict) -> None:
        """ Called at the end of the game. """
        pass
```

    RESPONSE:
    ```python
from typing import List, Tuple, Dict, Any
from dataclasses import dataclass
import random
import itertools
import math

from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient
from enum import Enum

# Helper Enums for clarity if needed (not strictly necessary if imported from type)
class PokerRound(Enum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3

# ---------------------------
# Card utilities and evaluator
# ---------------------------

RANKS = "23456789TJQKA"
SUITS = "cdhs"
RANK_TO_INT: Dict[str, int] = {r: i + 2 for i, r in enumerate(RANKS)}  # '2' -> 2, ..., 'A' -> 14
INT_TO_RANK: Dict[int, str] = {v: k for k, v in RANK_TO_INT.items()}

# Precompute combinations indices for 7 choose 5 and 6 choose 5 to speed up
COMB_IDX_7_5 = list(itertools.combinations(range(7), 5))
COMB_IDX_6_5 = list(itertools.combinations(range(6), 5))

def make_deck() -> List[str]:
    return [r + s for r in RANKS for s in SUITS]

def parse_card(card: str) -> Tuple[int, str]:
    # card like 'Ah', 'Td'
    r = card[0].upper()
    s = card[1].lower()
    return RANK_TO_INT[r], s

def hand_rank_5(cards5: List[str]) -> Tuple[int, List[int]]:
    """
    Evaluate a 5-card poker hand.
    Returns a tuple: (category, tiebreakers...) higher is better.
    Categories: 8 SF, 7 Quads, 6 Full House, 5 Flush, 4 Straight, 3 Trips, 2 Two Pair, 1 Pair, 0 High card
    """
    # Parse
    ranks = []
    suits = []
    for c in cards5:
        ri, si = parse_card(c)
        ranks.append(ri)
        suits.append(si)
    ranks.sort(reverse=True)
    # Count ranks
    counts: Dict[int, int] = {}
    for r in ranks:
        counts[r] = counts.get(r, 0) + 1
    # Determine flush
    suit_counts: Dict[str, int] = {}
    for s in suits:
        suit_counts[s] = suit_counts.get(s, 0) + 1
    is_flush = any(v == 5 for v in suit_counts.values())
    # Determine straight
    uniq = sorted(set(ranks), reverse=True)
    # Handle wheel straight A-2-3-4-5
    straight_high = 0
    if len(uniq) >= 5:
        # For exactly 5 cards, len(uniq) may be 5 or less (if duplicates)
        # Build a sequence from high to low
        u_desc = sorted(uniq, reverse=True)
        # Add wheel treatment by mapping Ace low
        # Check normal straight
        if u_desc[0] - u_desc[-1] == 4 and len(u_desc) == 5:
            # Could be straight, but there may be duplicates; since uniq it's fine
            if all(u_desc[i] - 1 == u_desc[i + 1] for i in range(4)):
                straight_high = u_desc[0]
        else:
            # General approach
            for i in range(len(u_desc) - 4):
                seq = u_desc[i:i + 5]
                if all(seq[j] - 1 == seq[j + 1] for j in range(4)):
                    straight_high = seq[0]
                    break
        # Wheel (A-5) check
        if straight_high == 0 and 14 in uniq:
            wheel = {14, 5, 4, 3, 2}
            if wheel.issubset(set(uniq)):
                straight_high = 5
    # Straight flush check
    if is_flush:
        flush_suit = max(suit_counts, key=lambda k: suit_counts[k])
        flush_cards = [parse_card(c)[0] for c in cards5 if c[1].lower() == flush_suit]
        flush_ranks = sorted(flush_cards, reverse=True)
        flush_uniq = sorted(set(flush_ranks), reverse=True)
        sf_high = 0
        if len(flush_uniq) >= 5:
            # There are exactly 5 cards in total, so flush_uniq should be length 5
            # But duplicates don't exist within flush_uniq
            u_desc = flush_uniq
            if u_desc[0] - u_desc[-1] == 4 and len(u_desc) == 5:
                if all(u_desc[i] - 1 == u_desc[i + 1] for i in range(4)):
                    sf_high = u_desc[0]
            else:
                for i in range(len(u_desc) - 4):
                    seq = u_desc[i:i + 5]
                    if all(seq[j] - 1 == seq[j + 1] for j in range(4)):
                        sf_high = seq[0]
                        break
            if sf_high == 0 and 14 in flush_uniq:
                if {14, 5, 4, 3, 2}.issubset(set(flush_uniq)):
                    sf_high = 5
        if sf_high:
            return (8, [sf_high])  # Straight flush, tiebreaker high card
    # Multiples (quads, full house, trips, pairs)
    # Sort by (count desc, rank desc)
    by_count = sorted(counts.items(), key=lambda x: (x[1], x[0]), reverse=True)
    counts_sorted = [cnt for rnk, cnt in by_count]
    ranks_sorted_by_count = [rnk for rnk, cnt in by_count]
    if counts_sorted[0] == 4:
        # Four of a kind: quad rank, kicker
        quad_rank = ranks_sorted_by_count[0]
        kicker = max([r for r in ranks if r != quad_rank])
        return (7, [quad_rank, kicker])
    if counts_sorted[0] == 3 and counts_sorted[1] == 2:
        # Full house: trip rank, pair rank
        trip_rank = ranks_sorted_by_count[0]
        pair_rank = ranks_sorted_by_count[1]
        return (6, [trip_rank, pair_rank])
    if is_flush:
        # Flush: top five ranks (already 5 cards)
        return (5, sorted(ranks, reverse=True))
    if straight_high:
        return (4, [straight_high])
    if counts_sorted[0] == 3:
        # Trips: trip rank + top two kickers
        trip_rank = ranks_sorted_by_count[0]
        kickers = sorted([r for r in ranks if r != trip_rank], reverse=True)[:2]
        return (3, [trip_rank] + kickers)
    if counts_sorted[0] == 2 and counts_sorted[1] == 2:
        # Two pair: top pair rank, second pair rank, kicker
        pair1 = max([r for r, c in counts.items() if c == 2])
        pair2 = min([r for r, c in counts.items() if c == 2])
        kicker = max([r for r in ranks if r != pair1 and r != pair2])
        return (2, [pair1, pair2, kicker])
    if counts_sorted[0] == 2:
        # One pair: pair rank + top three kickers
        pair_rank = ranks_sorted_by_count[0]
        kickers = sorted([r for r in ranks if r != pair_rank], reverse=True)[:3]
        return (1, [pair_rank] + kickers)
    # High card: five ranks
    return (0, sorted(ranks, reverse=True))

def best_hand_rank(cards: List[str]) -> Tuple[int, List[int]]:
    """
    Cards length 5-7. Returns best 5-card hand rank tuple using enumeration if needed.
    """
    n = len(cards)
    if n == 5:
        return hand_rank_5(cards)
    elif n == 6:
        best = None
        for idxs in COMB_IDX_6_5:
            pick = [cards[i] for i in idxs]
            r = hand_rank_5(pick)
            if (best is None) or (r > best):
                best = r
        return best
    elif n == 7:
        best = None
        for idxs in COMB_IDX_7_5:
            pick = [cards[i] for i in idxs]
            r = hand_rank_5(pick)
            if (best is None) or (r > best):
                best = r
        return best
    else:
        # Fallback for other sizes: enumerate all 5-card combos
        best = None
        for comb in itertools.combinations(range(n), 5):
            pick = [cards[i] for i in comb]
            r = hand_rank_5(pick)
            if (best is None) or (r > best):
                best = r
        return best

def compare_hands(cards_a: List[str], cards_b: List[str]) -> int:
    """
    Compare two hands (5-7 cards each including board).
    Return 1 if A>B, 0 if tie, -1 if A<B.
    """
    ra = best_hand_rank(cards_a)
    rb = best_hand_rank(cards_b)
    if ra > rb:
        return 1
    if rb > ra:
        return -1
    return 0

# ---------------------------
# Equity estimation
# ---------------------------

def chen_score(card1: str, card2: str) -> float:
    """
    Simplified Chen formula to get a rough preflop strength score.
    """
    r1, s1 = parse_card(card1)
    r2, s2 = parse_card(card2)
    hi = max(r1, r2)
    lo = min(r1, r2)
    suited = (card1[1].lower() == card2[1].lower())
    # Base highest card scores
    base_map = {
        14: 10.0, 13: 8.0, 12: 7.0, 11: 6.0,
        10: 5.0, 9: 4.5, 8: 4.0, 7: 3.5,
        6: 3.0, 5: 2.5, 4: 2.0, 3: 1.5, 2: 1.0
    }
    if r1 == r2:
        # Pair
        score = base_map[hi] * 2
        score = max(score, 5.0)  # minimum score for low pairs
        return score
    score = base_map[hi]
    # Suited adds
    if suited:
        score += 2.0
    # Gap penalties
    gap = (hi - lo - 1)
    if gap == 0:
        pass
    elif gap == 1:
        score -= 1.0
    elif gap == 2:
        score -= 2.0
    elif gap == 3:
        score -= 4.0
    else:
        score -= 5.0
    # Straight bonus for connectors / one-gap / two-gap if high enough
    if (gap <= 2) and (hi < 14) and (hi >= 5):
        score += 1.0
    # Round to nearest half
    return max(0.0, score)

def chen_to_equity_hu(score: float) -> float:
    """
    Rough mapping from Chen score to heads-up equity vs random.
    This is an approximation, returns value between ~0.35 and 0.8
    """
    # Ensure numeric
    s = max(0.0, float(score))
    # Map: 0 -> 0.38, 10 -> 0.53, 20 -> 0.66, 30 -> 0.76
    # Piecewise linear-ish using logistic-like function
    # equity ≈ 0.38 + 0.015*s + 0.0008*s^2, capped at 0.85
    e = 0.38 + 0.015 * s + 0.0008 * (s ** 2)
    return max(0.3, min(0.85, e))

def adjust_equity_for_multi(e_hu: float, opp_count: int) -> float:
    """
    Approximate equity versus multiple opponents assuming independence.
    """
    opp = max(1, opp_count)
    # P(beat all opp) ~ e_hu ** opp
    # But to soften, use blend with linear drop
    e_multi = (e_hu ** opp) * 0.7 + (max(0.0, e_hu - 0.05 * (opp - 1))) * 0.3
    return max(0.0, min(0.95, e_multi))

def estimate_equity_mc(my_cards: List[str], board_cards: List[str], opp_count: int, iters: int, rng: random.Random) -> float:
    """
    Monte Carlo equity estimation.
    """
    # Safety checks
    if not my_cards or len(my_cards) != 2:
        return 0.0
    opp = max(1, opp_count)
    deck = make_deck()
    known = set(my_cards + board_cards)
    deck = [c for c in deck if c not in known]
    if len(deck) < 2 * opp:
        # Not enough cards; return neutral-ish
        return 0.5

    wins = 0.0
    ties = 0.0
    total = 0.0
    # Pre-create list for sampling to avoid repeated building
    for _ in range(max(1, iters)):
        # Sample opponent hole cards and remaining board
        rng.shuffle(deck)
        # Opponents
        opp_holes = []
        idx = 0
        for _o in range(opp):
            opp_holes.append([deck[idx], deck[idx + 1]])
            idx += 2
        # Sample remaining community
        need_board = max(0, 5 - len(board_cards))
        rem_board = deck[idx: idx + need_board]
        # Our 7
        our_cards7 = my_cards + board_cards + rem_board
        our_rank = best_hand_rank(our_cards7)

        # Opponents compare
        best_vs = -1  # 1 if we win > all, 0 tie possible, -1 lose
        tie_with = 0
        lose = False
        for hole in opp_holes:
            opp_cards7 = hole + board_cards + rem_board
            cmp_res = 0
            rb = best_hand_rank(opp_cards7)
            if our_rank > rb:
                cmp_res = 1
            elif rb > our_rank:
                cmp_res = -1
            else:
                cmp_res = 0
            if cmp_res < 0:
                lose = True
                # break early
                best_vs = -1
                break
            elif cmp_res == 0:
                tie_with += 1
        if lose:
            total += 1.0
            continue
        # We didn't lose to any opponent
        if tie_with > 0:
            # Tie with at least one; assume pot split among ties+hero
            ties += 1.0
        else:
            wins += 1.0
        total += 1.0
    # Equity: wins + ties/ (ties + 1)? approximate: if tie_with opponents, hero's share ~ 1/(tie_with+1)
    # In our accounting, ties += 1 event. Approx equity = (wins + 0.5 * ties)/total as rough
    equity = (wins + 0.5 * ties) / (total + 1e-9)
    return max(0.0, min(1.0, equity))

# ---------------------------
# The Bot
# ---------------------------

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        self.starting_chips = 0
        self.blind_amount = 0
        self.big_blind_player_id = None
        self.small_blind_player_id = None
        self.all_players: List[int] = []
        self.hands_played = 0
        self.total_profit = 0
        self.rng = random.Random(1337)
        # Track last round number to reset per-hand state
        self.current_round_num = -1
        # Attempt to track our current hole cards if provided anywhere
        self.my_hole_cards: List[str] = []
        # Aggression and memory
        self.last_action = None

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        self.starting_chips = starting_chips
        self.blind_amount = blind_amount
        self.big_blind_player_id = big_blind_player_id
        self.small_blind_player_id = small_blind_player_id
        self.all_players = all_players[:] if all_players else []
        # If hands are provided (may not be per-hand), store for fallback
        # Expect two cards for our player possibly
        if isinstance(player_hands, list) and len(player_hands) >= 2:
            # Might be provided at start; but will quickly get outdated
            self.my_hole_cards = player_hands[:2]
        else:
            self.my_hole_cards = []

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # Reset per-hand or per-round information
        self.last_action = None
        # Attempt to detect our hole cards from any accessible field
        self._update_hole_cards_from_context(round_state)

        # Track round number to detect new hand
        self.current_round_num = getattr(round_state, "round_num", self.current_round_num)

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Returns the action for the player. """
        # Fail-safe: Always ensure valid returns even under unexpected state.
        try:
            # Update hole cards if possible
            self._update_hole_cards_from_context(round_state)

            # Determine stage
            stage = self._get_stage(round_state)
            board_cards = round_state.community_cards or []
            my_bet = self._get_my_bet(round_state)
            to_call = max(0, int(round_state.current_bet) - int(my_bet))
            can_check = (to_call <= 0)
            pot = max(0, int(round_state.pot))
            min_raise = int(getattr(round_state, "min_raise", 0) or 0)
            max_raise = int(getattr(round_state, "max_raise", 0) or 0)
            # Active opponents
            opp_count = self._estimate_active_opponents(round_state)
            opp_count = max(1, opp_count)

            # If we don't know our hole cards, play ultra-conservative
            if not self.my_hole_cards or len(self.my_hole_cards) != 2:
                if can_check:
                    return (PokerAction.CHECK, 0)
                else:
                    return (PokerAction.FOLD, 0)

            # Equity estimation
            equity = self._estimate_equity(stage, self.my_hole_cards, board_cards, opp_count, round_state, to_call, pot)

            # Pot odds for calling decision
            pot_odds = to_call / (pot + to_call + 1e-9) if to_call > 0 else 0.0
            # Multiway adjustment: require higher equity when more players remain
            multi_adj = 0.02 * max(0, opp_count - 1)
            call_threshold = min(0.95, pot_odds + multi_adj + 0.02)

            # Stack to pot ratio heuristic
            spr = (remaining_chips + 1e-9) / (pot + 1e-9) if pot > 0 else 10.0

            # Decide action based on current situation
            # 1) If we can check (no bet to us)
            if can_check:
                # Consider betting/raising for value with strong hands
                # Use stage-dependent threshold
                value_thresh = 0.64 if stage == PokerRound.PREFLOP else (0.58 if stage == PokerRound.FLOP else (0.6 if stage == PokerRound.TURN else 0.62))
                if equity > value_thresh and min_raise > 0 and max_raise >= min_raise:
                    # If very strong and low SPR, consider all-in
                    if equity > 0.82 or (equity > 0.72 and spr <= 2.0 and max_raise > 0):
                        self.last_action = (PokerAction.ALL_IN, 0)
                        return self.last_action
                    # Otherwise raise minimum to keep it valid
                    amount = min(max(min_raise, 1), max_raise)
                    self.last_action = (PokerAction.RAISE, amount)
                    return self.last_action
                # Otherwise check
                self.last_action = (PokerAction.CHECK, 0)
                return self.last_action

            # 2) We are facing a bet (to_call > 0)
            # If equity insufficient, fold
            if equity + 1e-9 < call_threshold:
                self.last_action = (PokerAction.FOLD, 0)
                return self.last_action

            # If equity comfortably above threshold, consider raise
            # Margin above threshold
            margin = equity - call_threshold
            if min_raise > 0 and max_raise >= min_raise and margin > 0.12:
                # If we have very strong equity or low SPR, shove
                if (equity > 0.80 and spr <= 4.0 and max_raise > 0) or (equity > 0.88):
                    self.last_action = (PokerAction.ALL_IN, 0)
                    return self.last_action
                # Otherwise raise minimally to avoid invalid raise sizing
                amount = min(max(min_raise, 1), max_raise)
                self.last_action = (PokerAction.RAISE, amount)
                return self.last_action

            # Default: call
            self.last_action = (PokerAction.CALL, 0)
            return self.last_action

        except Exception:
            # Fail-safe: never crash; fold or check safely
            try:
                # If we can check, do so, else fold
                my_bet = self._get_my_bet(round_state)
                to_call = max(0, int(round_state.current_bet) - int(my_bet))
                if to_call <= 0:
                    return (PokerAction.CHECK, 0)
                return (PokerAction.FOLD, 0)
            except Exception:
                # Absolute fallback
                return (PokerAction.FOLD, 0)

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        """ Called at the end of the round. """
        try:
            self.hands_played += 1
            # Potentially track profit
            delta = int(remaining_chips) - int(self.starting_chips)
            self.total_profit += delta
            # Reset hand cards
            self.my_hole_cards = []
        except Exception:
            # Ensure no exception is thrown
            pass

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # No-op or could log internally; keep robust
        pass

    # ---------------------------
    # Helper methods
    # ---------------------------

    def _get_stage(self, round_state: RoundStateClient) -> PokerRound:
        stage_name = (round_state.round or "").lower()
        if stage_name == 'preflop':
            return PokerRound.PREFLOP
        elif stage_name == 'flop':
            return PokerRound.FLOP
        elif stage_name == 'turn':
            return PokerRound.TURN
        elif stage_name == 'river':
            return PokerRound.RIVER
        # Fallback by number of community cards
        cc = len(round_state.community_cards or [])
        if cc == 0:
            return PokerRound.PREFLOP
        if cc == 3:
            return PokerRound.FLOP
        if cc == 4:
            return PokerRound.TURN
        return PokerRound.RIVER

    def _get_my_bet(self, round_state: RoundStateClient) -> int:
        # player_bets: Dict[str, int]
        try:
            pid = str(self.id)
            return int(round_state.player_bets.get(pid, 0))
        except Exception:
            return 0

    def _estimate_active_opponents(self, round_state: RoundStateClient) -> int:
        """
        Estimate number of opponents still in the hand.
        """
        # Prefer current_player list if available
        try:
            active = list(round_state.current_player) if round_state.current_player else []
            # Remove self
            if self.id in active:
                active_count = len(active) - 1
                return max(1, active_count)
            # Else try from actions: exclude folds
            acts = round_state.player_actions or {}
            # Count players not explicitly folded
            not_folded = [pid for pid, act in acts.items() if str(act).lower() != 'fold']
            # If player_actions uses string keys
            if not_folded:
                # Opponents approx = count - 1
                if str(self.id) in not_folded:
                    return max(1, len(not_folded) - 1)
                return max(1, len(not_folded))
        except Exception:
            pass
        # Fallback to table size minus one
        if self.all_players:
            return max(1, len(self.all_players) - 1)
        # Default 1 opponent
        return 1

    def _update_hole_cards_from_context(self, round_state: RoundStateClient):
        """
        Attempt to retrieve our hole cards from any available attributes.
        This method is defensive: it checks multiple potential places without throwing.
        """
        # If already have valid cards for current hand (2 cards), keep them
        if isinstance(self.my_hole_cards, list) and len(self.my_hole_cards) == 2:
            # Basic validity check of format 'Rs'
            if all(isinstance(c, str) and len(c) == 2 for c in self.my_hole_cards):
                return

        # Try to fetch from round_state if it unexpectedly contains them
        try:
            if hasattr(round_state, "player_hands") and isinstance(round_state.player_hands, dict):
                # Expect mapping from player id to hand list
                hand = round_state.player_hands.get(str(self.id))
                if isinstance(hand, list) and len(hand) >= 2:
                    self.my_hole_cards = hand[:2]
                    return
        except Exception:
            pass

        # Try attributes possibly set by engine or Bot
        try:
            if hasattr(self, "hand") and isinstance(getattr(self, "hand"), list):
                hand = getattr(self, "hand")
                if len(hand) >= 2 and all(isinstance(c, str) and len(c) == 2 for c in hand[:2]):
                    self.my_hole_cards = hand[:2]
                    return
        except Exception:
            pass

        try:
            if hasattr(self, "hole_cards") and isinstance(getattr(self, "hole_cards"), list):
                hand = getattr(self, "hole_cards")
                if len(hand) >= 2 and all(isinstance(c, str) and len(c) == 2 for c in hand[:2]):
                    self.my_hole_cards = hand[:2]
                    return
        except Exception:
            pass

        try:
            if hasattr(self, "get_hand") and callable(getattr(self, "get_hand")):
                hand = getattr(self, "get_hand")()
                if isinstance(hand, list) and len(hand) >= 2:
                    self.my_hole_cards = hand[:2]
                    return
        except Exception:
            pass

        # Fallback: keep as is (may be empty); decisions will be conservative without cards

    def _estimate_equity(self, stage: PokerRound, my_cards: List[str], board_cards: List[str], opp_count: int, round_state: RoundStateClient, to_call: int, pot: int) -> float:
        """
        Stage-aware equity estimation with adaptive MC iterations.
        """
        # Preflop
        if stage == PokerRound.PREFLOP:
            # If heavy action (large to_call vs pot), do MC more iterations
            pressure = 0.0
            try:
                pressure = to_call / (pot + to_call + 1e-9)
            except Exception:
                pressure = 0.0
            # Base iterations
            base_iters = 120
            if pressure > 0.4:
                base_iters = 180
            if opp_count >= 3:
                base_iters = max(base_iters - 30, 80)
            # Ensure performance bounds
            base_iters = int(max(60, min(220, base_iters)))
            # MC preflop
            e_mc = estimate_equity_mc(my_cards, [], opp_count, base_iters, self.rng)
            return max(0.0, min(1.0, e_mc))

        # Postflop
        # More board info -> fewer unknowns -> fewer iters needed
        cc = len(board_cards or [])
        if cc == 3:
            iters = 220
        elif cc == 4:
            iters = 260
        else:
            iters = 320
        # Adjust for opp count
        if opp_count >= 3:
            iters = max(160, iters - 40)
        # Ensure not too high
        iters = int(min(400, max(120, iters)))
        e_post = estimate_equity_mc(my_cards, board_cards, opp_count, iters, self.rng)
        return max(0.0, min(1.0, e_post))
```

```text
```

    RAW API RESPONSE:
    {
  "choices": [
    {
      "message": {
        "content": "```python\nfrom typing import List, Tuple, Dict, Any\nfrom dataclasses import dataclass\nimport random\nimport itertools\nimport math\n\nfrom bot import Bot\nfrom type.poker_action import PokerAction\nfrom type.round_state import RoundStateClient\nfrom enum import Enum\n\n# Helper Enums for clarity if needed (not strictly necessary if imported from type)\nclass PokerRound(Enum):\n    PREFLOP = 0\n    FLOP = 1\n    TURN = 2\n    RIVER = 3\n\n# ---------------------------\n# Card utilities and evaluator\n# ---------------------------\n\nRANKS = \"23456789TJQKA\"\nSUITS = \"cdhs\"\nRANK_TO_INT: Dict[str, int] = {r: i + 2 for i, r in enumerate(RANKS)}  # '2' -> 2, ..., 'A' -> 14\nINT_TO_RANK: Dict[int, str] = {v: k for k, v in RANK_TO_INT.items()}\n\n# Precompute combinations indices for 7 choose 5 and 6 choose 5 to speed up\nCOMB_IDX_7_5 = list(itertools.combinations(range(7), 5))\nCOMB_IDX_6_5 = list(itertools.combinations(range(6), 5))\n\ndef make_deck() -> List[str]:\n    return [r + s for r in RANKS for s in SUITS]\n\ndef parse_card(card: str) -> Tuple[int, str]:\n    # card like 'Ah', 'Td'\n    r = card[0].upper()\n    s = card[1].lower()\n    return RANK_TO_INT[r], s\n\ndef hand_rank_5(cards5: List[str]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Evaluate a 5-card poker hand.\n    Returns a tuple: (category, tiebreakers...) higher is better.\n    Categories: 8 SF, 7 Quads, 6 Full House, 5 Flush, 4 Straight, 3 Trips, 2 Two Pair, 1 Pair, 0 High card\n    \"\"\"\n    # Parse\n    ranks = []\n    suits = []\n    for c in cards5:\n        ri, si = parse_card(c)\n        ranks.append(ri)\n        suits.append(si)\n    ranks.sort(reverse=True)\n    # Count ranks\n    counts: Dict[int, int] = {}\n    for r in ranks:\n        counts[r] = counts.get(r, 0) + 1\n    # Determine flush\n    suit_counts: Dict[str, int] = {}\n    for s in suits:\n        suit_counts[s] = suit_counts.get(s, 0) + 1\n    is_flush = any(v == 5 for v in suit_counts.values())\n    # Determine straight\n    uniq = sorted(set(ranks), reverse=True)\n    # Handle wheel straight A-2-3-4-5\n    straight_high = 0\n    if len(uniq) >= 5:\n        # For exactly 5 cards, len(uniq) may be 5 or less (if duplicates)\n        # Build a sequence from high to low\n        u_desc = sorted(uniq, reverse=True)\n        # Add wheel treatment by mapping Ace low\n        # Check normal straight\n        if u_desc[0] - u_desc[-1] == 4 and len(u_desc) == 5:\n            # Could be straight, but there may be duplicates; since uniq it's fine\n            if all(u_desc[i] - 1 == u_desc[i + 1] for i in range(4)):\n                straight_high = u_desc[0]\n        else:\n            # General approach\n            for i in range(len(u_desc) - 4):\n                seq = u_desc[i:i + 5]\n                if all(seq[j] - 1 == seq[j + 1] for j in range(4)):\n                    straight_high = seq[0]\n                    break\n        # Wheel (A-5) check\n        if straight_high == 0 and 14 in uniq:\n            wheel = {14, 5, 4, 3, 2}\n            if wheel.issubset(set(uniq)):\n                straight_high = 5\n    # Straight flush check\n    if is_flush:\n        flush_suit = max(suit_counts, key=lambda k: suit_counts[k])\n        flush_cards = [parse_card(c)[0] for c in cards5 if c[1].lower() == flush_suit]\n        flush_ranks = sorted(flush_cards, reverse=True)\n        flush_uniq = sorted(set(flush_ranks), reverse=True)\n        sf_high = 0\n        if len(flush_uniq) >= 5:\n            # There are exactly 5 cards in total, so flush_uniq should be length 5\n            # But duplicates don't exist within flush_uniq\n            u_desc = flush_uniq\n            if u_desc[0] - u_desc[-1] == 4 and len(u_desc) == 5:\n                if all(u_desc[i] - 1 == u_desc[i + 1] for i in range(4)):\n                    sf_high = u_desc[0]\n            else:\n                for i in range(len(u_desc) - 4):\n                    seq = u_desc[i:i + 5]\n                    if all(seq[j] - 1 == seq[j + 1] for j in range(4)):\n                        sf_high = seq[0]\n                        break\n            if sf_high == 0 and 14 in flush_uniq:\n                if {14, 5, 4, 3, 2}.issubset(set(flush_uniq)):\n                    sf_high = 5\n        if sf_high:\n            return (8, [sf_high])  # Straight flush, tiebreaker high card\n    # Multiples (quads, full house, trips, pairs)\n    # Sort by (count desc, rank desc)\n    by_count = sorted(counts.items(), key=lambda x: (x[1], x[0]), reverse=True)\n    counts_sorted = [cnt for rnk, cnt in by_count]\n    ranks_sorted_by_count = [rnk for rnk, cnt in by_count]\n    if counts_sorted[0] == 4:\n        # Four of a kind: quad rank, kicker\n        quad_rank = ranks_sorted_by_count[0]\n        kicker = max([r for r in ranks if r != quad_rank])\n        return (7, [quad_rank, kicker])\n    if counts_sorted[0] == 3 and counts_sorted[1] == 2:\n        # Full house: trip rank, pair rank\n        trip_rank = ranks_sorted_by_count[0]\n        pair_rank = ranks_sorted_by_count[1]\n        return (6, [trip_rank, pair_rank])\n    if is_flush:\n        # Flush: top five ranks (already 5 cards)\n        return (5, sorted(ranks, reverse=True))\n    if straight_high:\n        return (4, [straight_high])\n    if counts_sorted[0] == 3:\n        # Trips: trip rank + top two kickers\n        trip_rank = ranks_sorted_by_count[0]\n        kickers = sorted([r for r in ranks if r != trip_rank], reverse=True)[:2]\n        return (3, [trip_rank] + kickers)\n    if counts_sorted[0] == 2 and counts_sorted[1] == 2:\n        # Two pair: top pair rank, second pair rank, kicker\n        pair1 = max([r for r, c in counts.items() if c == 2])\n        pair2 = min([r for r, c in counts.items() if c == 2])\n        kicker = max([r for r in ranks if r != pair1 and r != pair2])\n        return (2, [pair1, pair2, kicker])\n    if counts_sorted[0] == 2:\n        # One pair: pair rank + top three kickers\n        pair_rank = ranks_sorted_by_count[0]\n        kickers = sorted([r for r in ranks if r != pair_rank], reverse=True)[:3]\n        return (1, [pair_rank] + kickers)\n    # High card: five ranks\n    return (0, sorted(ranks, reverse=True))\n\ndef best_hand_rank(cards: List[str]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Cards length 5-7. Returns best 5-card hand rank tuple using enumeration if needed.\n    \"\"\"\n    n = len(cards)\n    if n == 5:\n        return hand_rank_5(cards)\n    elif n == 6:\n        best = None\n        for idxs in COMB_IDX_6_5:\n            pick = [cards[i] for i in idxs]\n            r = hand_rank_5(pick)\n            if (best is None) or (r > best):\n                best = r\n        return best\n    elif n == 7:\n        best = None\n        for idxs in COMB_IDX_7_5:\n            pick = [cards[i] for i in idxs]\n            r = hand_rank_5(pick)\n            if (best is None) or (r > best):\n                best = r\n        return best\n    else:\n        # Fallback for other sizes: enumerate all 5-card combos\n        best = None\n        for comb in itertools.combinations(range(n), 5):\n            pick = [cards[i] for i in comb]\n            r = hand_rank_5(pick)\n            if (best is None) or (r > best):\n                best = r\n        return best\n\ndef compare_hands(cards_a: List[str], cards_b: List[str]) -> int:\n    \"\"\"\n    Compare two hands (5-7 cards each including board).\n    Return 1 if A>B, 0 if tie, -1 if A<B.\n    \"\"\"\n    ra = best_hand_rank(cards_a)\n    rb = best_hand_rank(cards_b)\n    if ra > rb:\n        return 1\n    if rb > ra:\n        return -1\n    return 0\n\n# ---------------------------\n# Equity estimation\n# ---------------------------\n\ndef chen_score(card1: str, card2: str) -> float:\n    \"\"\"\n    Simplified Chen formula to get a rough preflop strength score.\n    \"\"\"\n    r1, s1 = parse_card(card1)\n    r2, s2 = parse_card(card2)\n    hi = max(r1, r2)\n    lo = min(r1, r2)\n    suited = (card1[1].lower() == card2[1].lower())\n    # Base highest card scores\n    base_map = {\n        14: 10.0, 13: 8.0, 12: 7.0, 11: 6.0,\n        10: 5.0, 9: 4.5, 8: 4.0, 7: 3.5,\n        6: 3.0, 5: 2.5, 4: 2.0, 3: 1.5, 2: 1.0\n    }\n    if r1 == r2:\n        # Pair\n        score = base_map[hi] * 2\n        score = max(score, 5.0)  # minimum score for low pairs\n        return score\n    score = base_map[hi]\n    # Suited adds\n    if suited:\n        score += 2.0\n    # Gap penalties\n    gap = (hi - lo - 1)\n    if gap == 0:\n        pass\n    elif gap == 1:\n        score -= 1.0\n    elif gap == 2:\n        score -= 2.0\n    elif gap == 3:\n        score -= 4.0\n    else:\n        score -= 5.0\n    # Straight bonus for connectors / one-gap / two-gap if high enough\n    if (gap <= 2) and (hi < 14) and (hi >= 5):\n        score += 1.0\n    # Round to nearest half\n    return max(0.0, score)\n\ndef chen_to_equity_hu(score: float) -> float:\n    \"\"\"\n    Rough mapping from Chen score to heads-up equity vs random.\n    This is an approximation, returns value between ~0.35 and 0.8\n    \"\"\"\n    # Ensure numeric\n    s = max(0.0, float(score))\n    # Map: 0 -> 0.38, 10 -> 0.53, 20 -> 0.66, 30 -> 0.76\n    # Piecewise linear-ish using logistic-like function\n    # equity \u2248 0.38 + 0.015*s + 0.0008*s^2, capped at 0.85\n    e = 0.38 + 0.015 * s + 0.0008 * (s ** 2)\n    return max(0.3, min(0.85, e))\n\ndef adjust_equity_for_multi(e_hu: float, opp_count: int) -> float:\n    \"\"\"\n    Approximate equity versus multiple opponents assuming independence.\n    \"\"\"\n    opp = max(1, opp_count)\n    # P(beat all opp) ~ e_hu ** opp\n    # But to soften, use blend with linear drop\n    e_multi = (e_hu ** opp) * 0.7 + (max(0.0, e_hu - 0.05 * (opp - 1))) * 0.3\n    return max(0.0, min(0.95, e_multi))\n\ndef estimate_equity_mc(my_cards: List[str], board_cards: List[str], opp_count: int, iters: int, rng: random.Random) -> float:\n    \"\"\"\n    Monte Carlo equity estimation.\n    \"\"\"\n    # Safety checks\n    if not my_cards or len(my_cards) != 2:\n        return 0.0\n    opp = max(1, opp_count)\n    deck = make_deck()\n    known = set(my_cards + board_cards)\n    deck = [c for c in deck if c not in known]\n    if len(deck) < 2 * opp:\n        # Not enough cards; return neutral-ish\n        return 0.5\n\n    wins = 0.0\n    ties = 0.0\n    total = 0.0\n    # Pre-create list for sampling to avoid repeated building\n    for _ in range(max(1, iters)):\n        # Sample opponent hole cards and remaining board\n        rng.shuffle(deck)\n        # Opponents\n        opp_holes = []\n        idx = 0\n        for _o in range(opp):\n            opp_holes.append([deck[idx], deck[idx + 1]])\n            idx += 2\n        # Sample remaining community\n        need_board = max(0, 5 - len(board_cards))\n        rem_board = deck[idx: idx + need_board]\n        # Our 7\n        our_cards7 = my_cards + board_cards + rem_board\n        our_rank = best_hand_rank(our_cards7)\n\n        # Opponents compare\n        best_vs = -1  # 1 if we win > all, 0 tie possible, -1 lose\n        tie_with = 0\n        lose = False\n        for hole in opp_holes:\n            opp_cards7 = hole + board_cards + rem_board\n            cmp_res = 0\n            rb = best_hand_rank(opp_cards7)\n            if our_rank > rb:\n                cmp_res = 1\n            elif rb > our_rank:\n                cmp_res = -1\n            else:\n                cmp_res = 0\n            if cmp_res < 0:\n                lose = True\n                # break early\n                best_vs = -1\n                break\n            elif cmp_res == 0:\n                tie_with += 1\n        if lose:\n            total += 1.0\n            continue\n        # We didn't lose to any opponent\n        if tie_with > 0:\n            # Tie with at least one; assume pot split among ties+hero\n            ties += 1.0\n        else:\n            wins += 1.0\n        total += 1.0\n    # Equity: wins + ties/ (ties + 1)? approximate: if tie_with opponents, hero's share ~ 1/(tie_with+1)\n    # In our accounting, ties += 1 event. Approx equity = (wins + 0.5 * ties)/total as rough\n    equity = (wins + 0.5 * ties) / (total + 1e-9)\n    return max(0.0, min(1.0, equity))\n\n# ---------------------------\n# The Bot\n# ---------------------------\n\nclass SimplePlayer(Bot):\n    def __init__(self):\n        super().__init__()\n        self.starting_chips = 0\n        self.blind_amount = 0\n        self.big_blind_player_id = None\n        self.small_blind_player_id = None\n        self.all_players: List[int] = []\n        self.hands_played = 0\n        self.total_profit = 0\n        self.rng = random.Random(1337)\n        # Track last round number to reset per-hand state\n        self.current_round_num = -1\n        # Attempt to track our current hole cards if provided anywhere\n        self.my_hole_cards: List[str] = []\n        # Aggression and memory\n        self.last_action = None\n\n    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):\n        self.starting_chips = starting_chips\n        self.blind_amount = blind_amount\n        self.big_blind_player_id = big_blind_player_id\n        self.small_blind_player_id = small_blind_player_id\n        self.all_players = all_players[:] if all_players else []\n        # If hands are provided (may not be per-hand), store for fallback\n        # Expect two cards for our player possibly\n        if isinstance(player_hands, list) and len(player_hands) >= 2:\n            # Might be provided at start; but will quickly get outdated\n            self.my_hole_cards = player_hands[:2]\n        else:\n            self.my_hole_cards = []\n\n    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):\n        # Reset per-hand or per-round information\n        self.last_action = None\n        # Attempt to detect our hole cards from any accessible field\n        self._update_hole_cards_from_context(round_state)\n\n        # Track round number to detect new hand\n        self.current_round_num = getattr(round_state, \"round_num\", self.current_round_num)\n\n    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:\n        \"\"\" Returns the action for the player. \"\"\"\n        # Fail-safe: Always ensure valid returns even under unexpected state.\n        try:\n            # Update hole cards if possible\n            self._update_hole_cards_from_context(round_state)\n\n            # Determine stage\n            stage = self._get_stage(round_state)\n            board_cards = round_state.community_cards or []\n            my_bet = self._get_my_bet(round_state)\n            to_call = max(0, int(round_state.current_bet) - int(my_bet))\n            can_check = (to_call <= 0)\n            pot = max(0, int(round_state.pot))\n            min_raise = int(getattr(round_state, \"min_raise\", 0) or 0)\n            max_raise = int(getattr(round_state, \"max_raise\", 0) or 0)\n            # Active opponents\n            opp_count = self._estimate_active_opponents(round_state)\n            opp_count = max(1, opp_count)\n\n            # If we don't know our hole cards, play ultra-conservative\n            if not self.my_hole_cards or len(self.my_hole_cards) != 2:\n                if can_check:\n                    return (PokerAction.CHECK, 0)\n                else:\n                    return (PokerAction.FOLD, 0)\n\n            # Equity estimation\n            equity = self._estimate_equity(stage, self.my_hole_cards, board_cards, opp_count, round_state, to_call, pot)\n\n            # Pot odds for calling decision\n            pot_odds = to_call / (pot + to_call + 1e-9) if to_call > 0 else 0.0\n            # Multiway adjustment: require higher equity when more players remain\n            multi_adj = 0.02 * max(0, opp_count - 1)\n            call_threshold = min(0.95, pot_odds + multi_adj + 0.02)\n\n            # Stack to pot ratio heuristic\n            spr = (remaining_chips + 1e-9) / (pot + 1e-9) if pot > 0 else 10.0\n\n            # Decide action based on current situation\n            # 1) If we can check (no bet to us)\n            if can_check:\n                # Consider betting/raising for value with strong hands\n                # Use stage-dependent threshold\n                value_thresh = 0.64 if stage == PokerRound.PREFLOP else (0.58 if stage == PokerRound.FLOP else (0.6 if stage == PokerRound.TURN else 0.62))\n                if equity > value_thresh and min_raise > 0 and max_raise >= min_raise:\n                    # If very strong and low SPR, consider all-in\n                    if equity > 0.82 or (equity > 0.72 and spr <= 2.0 and max_raise > 0):\n                        self.last_action = (PokerAction.ALL_IN, 0)\n                        return self.last_action\n                    # Otherwise raise minimum to keep it valid\n                    amount = min(max(min_raise, 1), max_raise)\n                    self.last_action = (PokerAction.RAISE, amount)\n                    return self.last_action\n                # Otherwise check\n                self.last_action = (PokerAction.CHECK, 0)\n                return self.last_action\n\n            # 2) We are facing a bet (to_call > 0)\n            # If equity insufficient, fold\n            if equity + 1e-9 < call_threshold:\n                self.last_action = (PokerAction.FOLD, 0)\n                return self.last_action\n\n            # If equity comfortably above threshold, consider raise\n            # Margin above threshold\n            margin = equity - call_threshold\n            if min_raise > 0 and max_raise >= min_raise and margin > 0.12:\n                # If we have very strong equity or low SPR, shove\n                if (equity > 0.80 and spr <= 4.0 and max_raise > 0) or (equity > 0.88):\n                    self.last_action = (PokerAction.ALL_IN, 0)\n                    return self.last_action\n                # Otherwise raise minimally to avoid invalid raise sizing\n                amount = min(max(min_raise, 1), max_raise)\n                self.last_action = (PokerAction.RAISE, amount)\n                return self.last_action\n\n            # Default: call\n            self.last_action = (PokerAction.CALL, 0)\n            return self.last_action\n\n        except Exception:\n            # Fail-safe: never crash; fold or check safely\n            try:\n                # If we can check, do so, else fold\n                my_bet = self._get_my_bet(round_state)\n                to_call = max(0, int(round_state.current_bet) - int(my_bet))\n                if to_call <= 0:\n                    return (PokerAction.CHECK, 0)\n                return (PokerAction.FOLD, 0)\n            except Exception:\n                # Absolute fallback\n                return (PokerAction.FOLD, 0)\n\n    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):\n        \"\"\" Called at the end of the round. \"\"\"\n        try:\n            self.hands_played += 1\n            # Potentially track profit\n            delta = int(remaining_chips) - int(self.starting_chips)\n            self.total_profit += delta\n            # Reset hand cards\n            self.my_hole_cards = []\n        except Exception:\n            # Ensure no exception is thrown\n            pass\n\n    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):\n        # No-op or could log internally; keep robust\n        pass\n\n    # ---------------------------\n    # Helper methods\n    # ---------------------------\n\n    def _get_stage(self, round_state: RoundStateClient) -> PokerRound:\n        stage_name = (round_state.round or \"\").lower()\n        if stage_name == 'preflop':\n            return PokerRound.PREFLOP\n        elif stage_name == 'flop':\n            return PokerRound.FLOP\n        elif stage_name == 'turn':\n            return PokerRound.TURN\n        elif stage_name == 'river':\n            return PokerRound.RIVER\n        # Fallback by number of community cards\n        cc = len(round_state.community_cards or [])\n        if cc == 0:\n            return PokerRound.PREFLOP\n        if cc == 3:\n            return PokerRound.FLOP\n        if cc == 4:\n            return PokerRound.TURN\n        return PokerRound.RIVER\n\n    def _get_my_bet(self, round_state: RoundStateClient) -> int:\n        # player_bets: Dict[str, int]\n        try:\n            pid = str(self.id)\n            return int(round_state.player_bets.get(pid, 0))\n        except Exception:\n            return 0\n\n    def _estimate_active_opponents(self, round_state: RoundStateClient) -> int:\n        \"\"\"\n        Estimate number of opponents still in the hand.\n        \"\"\"\n        # Prefer current_player list if available\n        try:\n            active = list(round_state.current_player) if round_state.current_player else []\n            # Remove self\n            if self.id in active:\n                active_count = len(active) - 1\n                return max(1, active_count)\n            # Else try from actions: exclude folds\n            acts = round_state.player_actions or {}\n            # Count players not explicitly folded\n            not_folded = [pid for pid, act in acts.items() if str(act).lower() != 'fold']\n            # If player_actions uses string keys\n            if not_folded:\n                # Opponents approx = count - 1\n                if str(self.id) in not_folded:\n                    return max(1, len(not_folded) - 1)\n                return max(1, len(not_folded))\n        except Exception:\n            pass\n        # Fallback to table size minus one\n        if self.all_players:\n            return max(1, len(self.all_players) - 1)\n        # Default 1 opponent\n        return 1\n\n    def _update_hole_cards_from_context(self, round_state: RoundStateClient):\n        \"\"\"\n        Attempt to retrieve our hole cards from any available attributes.\n        This method is defensive: it checks multiple potential places without throwing.\n        \"\"\"\n        # If already have valid cards for current hand (2 cards), keep them\n        if isinstance(self.my_hole_cards, list) and len(self.my_hole_cards) == 2:\n            # Basic validity check of format 'Rs'\n            if all(isinstance(c, str) and len(c) == 2 for c in self.my_hole_cards):\n                return\n\n        # Try to fetch from round_state if it unexpectedly contains them\n        try:\n            if hasattr(round_state, \"player_hands\") and isinstance(round_state.player_hands, dict):\n                # Expect mapping from player id to hand list\n                hand = round_state.player_hands.get(str(self.id))\n                if isinstance(hand, list) and len(hand) >= 2:\n                    self.my_hole_cards = hand[:2]\n                    return\n        except Exception:\n            pass\n\n        # Try attributes possibly set by engine or Bot\n        try:\n            if hasattr(self, \"hand\") and isinstance(getattr(self, \"hand\"), list):\n                hand = getattr(self, \"hand\")\n                if len(hand) >= 2 and all(isinstance(c, str) and len(c) == 2 for c in hand[:2]):\n                    self.my_hole_cards = hand[:2]\n                    return\n        except Exception:\n            pass\n\n        try:\n            if hasattr(self, \"hole_cards\") and isinstance(getattr(self, \"hole_cards\"), list):\n                hand = getattr(self, \"hole_cards\")\n                if len(hand) >= 2 and all(isinstance(c, str) and len(c) == 2 for c in hand[:2]):\n                    self.my_hole_cards = hand[:2]\n                    return\n        except Exception:\n            pass\n\n        try:\n            if hasattr(self, \"get_hand\") and callable(getattr(self, \"get_hand\")):\n                hand = getattr(self, \"get_hand\")()\n                if isinstance(hand, list) and len(hand) >= 2:\n                    self.my_hole_cards = hand[:2]\n                    return\n        except Exception:\n            pass\n\n        # Fallback: keep as is (may be empty); decisions will be conservative without cards\n\n    def _estimate_equity(self, stage: PokerRound, my_cards: List[str], board_cards: List[str], opp_count: int, round_state: RoundStateClient, to_call: int, pot: int) -> float:\n        \"\"\"\n        Stage-aware equity estimation with adaptive MC iterations.\n        \"\"\"\n        # Preflop\n        if stage == PokerRound.PREFLOP:\n            # If heavy action (large to_call vs pot), do MC more iterations\n            pressure = 0.0\n            try:\n                pressure = to_call / (pot + to_call + 1e-9)\n            except Exception:\n                pressure = 0.0\n            # Base iterations\n            base_iters = 120\n            if pressure > 0.4:\n                base_iters = 180\n            if opp_count >= 3:\n                base_iters = max(base_iters - 30, 80)\n            # Ensure performance bounds\n            base_iters = int(max(60, min(220, base_iters)))\n            # MC preflop\n            e_mc = estimate_equity_mc(my_cards, [], opp_count, base_iters, self.rng)\n            return max(0.0, min(1.0, e_mc))\n\n        # Postflop\n        # More board info -> fewer unknowns -> fewer iters needed\n        cc = len(board_cards or [])\n        if cc == 3:\n            iters = 220\n        elif cc == 4:\n            iters = 260\n        else:\n            iters = 320\n        # Adjust for opp count\n        if opp_count >= 3:\n            iters = max(160, iters - 40)\n        # Ensure not too high\n        iters = int(min(400, max(120, iters)))\n        e_post = estimate_equity_mc(my_cards, board_cards, opp_count, iters, self.rng)\n        return max(0.0, min(1.0, e_post))\n```\n\n```text\n```",
        "role": "assistant"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "input_tokens": 2315,
    "input_tokens_details": {
      "cached_tokens": 128
    },
    "output_tokens": 13509,
    "output_tokens_details": {
      "reasoning_tokens": 6848
    },
    "total_tokens": 15824
  },
  "model": "gpt-5-2025-08-07",
  "id": "resp_6897f681ec3081958833a11e9da8727100ccaa5c59e5cdd4",
  "object": "chat.completion",
  "reasoning": {
    "id": "rs_6897f68297748195a5bda8f18c6b66ab00ccaa5c59e5cdd4",
    "type": "reasoning",
    "summary": []
  }
}
    ================================================================================
    
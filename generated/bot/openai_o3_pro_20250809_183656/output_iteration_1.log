
    ================================================================================
    TIMESTAMP: 2025-08-09 18:40:22
    MODEL: openai/o3-pro (OpenAI Direct API)
    PROMPT LENGTH: 9908 characters
    RESPONSE LENGTH: 10957 characters
    USAGE: {
  "input_tokens": 2315,
  "input_tokens_details": {
    "cached_tokens": 0
  },
  "output_tokens": 5693,
  "output_tokens_details": {
    "reasoning_tokens": 3072
  },
  "total_tokens": 8008
}

    PROMPT:
    You are tasked with submitting a poker bot to a No-Limit Texas Hold'em poker bot competition: Husky Hold'em.

**Detailed Game Rules**
- No-Limit Texas Hold'em with 2-10 players (often 6-handed tables); bots compete in heads-up or multi-player matches hosted by a central game server.
- Players start with $10,000 chips at the simulation start; simulations run for n games (more than 10 per run); blinds rotate and increase every n games (e.g., after certain rounds); big/small blinds are posted pre-flop.
- Goal: Maximize delta money (ending chips minus starting chips); if a player runs out of chips, they are eliminated from that table; no rebuys.
- Each hand has 4 betting rounds: Pre-flop (after hole cards and blinds), Flop (3 community cards), Turn (1 community card), River (1 community card).
- Actions: Fold, Check, Call, Raise (any amount up to stack, no limit), All-in.
- Hand rankings: Royal flush > Straight flush > Four of a kind > Full house > Flush > Straight > Three of a kind > Two pair > One pair > High card.
- Showdown: If multiple players remain after river betting, best 5-card hand (using any combination of 2 hole cards + 5 community cards) wins the pot; side pots form for all-ins with eligible players.
- Technical Limits: 30 seconds max per move (timeout causes automatic fold); 100MB max memory usage; any error/exception causes automatic fold; all bots are given the same compute limits.

Your task: Implement winning bot in player.py by subclassing Bot as in the template below and follow the above game rules.

Bot Design and Competition Rules:

1. Your bot must subclass Bot as SimplePlayer, implementing all required methods exactly as in the template. Preserve the class name SimplePlayer for compatibility with the game server. The template for the class is as
**SimplePlayer Template:**
```python
from typing import List, Tuple
from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

class SimplePlayer(Bot):
    def __init__(self):
        super().__init__()
        # TODO implement this

    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]):
        # TODO implement this

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # TODO implement this

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Returns the action for the player. """
        # TODO implement this

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        """ Called at the end of the round. """
        # TODO implement this

    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict):
        # TODO implement this
```
2. DO NOT rename or remove any predefined methods (on_start, on_round_start, get_action, on_end_round, on_end_game), and do not change their signatures.
3. You may add helper functions and instance variables for strategy or tracking.
4. Your bot should be able to abide by no limit texas hold'em rules and handle side pots, all-ins, blind increases, multi-way pots, and be error-free (no exceptions).
5. For each action, always return valid actions:
    - For RAISE: the amount raise combine with your current bet must be larger than the the current raise.
    - For CALL: You don't need to specify the amount you call, it default to match exactly the amount needed to call (current_bet - your bet).
    - For CHECK: You can't check if round's current bet is larger than 0. Resort to other action (eg CALL, RAISE, ALL_IN).
    - For ALL_IN: You don't need to specify the amount you all in, it will default to all your current money.
    - **INVALID ACTION WILL MAKE YOU LOSE MONEY (automatic result in fold if the condition is not match for each action), so logic must always check bounds and edge cases**.
6. If you use any external libraries, they must be listed in requirements.txt (pure Python only).
7. Implement your bot with SimplePlayer. See full RoundStateClient, PokerAction, and PokerRound definitions below.
8. Your bot should maximize delta money (ending chips minus starting chips). Positive mean gaining money, the more money you gain the better.
9. There might will be data on previous run (error and game score) if this is not the first time you implement. If there is error, fix it so your bot can run. Try to improve your bot from previous round.
10. If there are no usage of external requirements, the text secion for requirement must be empty. DO NOT PUT ANYTHING ELSE. If you want to use any external library, you must put it in that text block
11. Your response must consist ONLY of two files: the complete player.py (as a Python code block) implementing the bot with all template elements preserved plus your improvements, and requirements.txt (as a text block) listing any dependencies (pure Python only, e.g., numpy if needed for calculations). Do not include any other text, explanations, or outputs. See example response below:
Example response:
```python
<Your python code>
```

```text
numpy
matplotlib
<any external library you want to use, put it here>
...
```
12. Your implementation MUST BE IN FULL not putting stub method or guideline. Everything in SimplePlayer must be ready to the detail and ready to run.
13. When you do division, make sure to make it prone to error divide by zero by adding some small delta.
14. The pool of submitted bots, including your bot, will be organized into 6-handed poker tables where every possible combination of 6 bots forms a separate table. Each table will play exactly 1,000 hands, with chip stacks carrying over between hands within the same table. 
15. At the end of each table, delta money is calculated for each bot using the formula: final chip count minus 10,000 (initial chip amount). Your bot's total tournament score is determined by summing its delta money across all tables it participates in. The bot with the highest cumulative delta money across all tables wins the tournament.
16. Your bot will undergo iterative testing across 5 rounds, where each round involves playing 10 hands of heads-up poker against a house bot. After each round, you will receive either the complete game log showing performance results or any compilation/simulation errors that occurred while attempting to run your bot. Use this feedback to refine your implementation in subsequent iterations.

**References**

**RoundStateClient Full Definition:**
```python
from dataclasses import dataclass
from typing import Dict, List, Any

@dataclass
class RoundStateClient:
    round_num: int # The number of the current round
    round: str # e.g., 'Preflop', 'Flop', 'Turn', 'River'
    community_cards: List[str] # List of community cards, e.g., ['Ah', 'Ks', '3d']
    pot: int # The total pot
    current_player: List[int] # The ids of the current players
    current_bet: int # The current bet (need to match round's current bet minus your current bet if you want to call)
    min_raise: int  # Minimum raise amount
    max_raise: int  # Maximum raise amount (your remaining chips)
    player_bets: Dict[str, int]  # Bets by player ID
    player_actions: Dict[str, str]  # Actions by player ID, e.g., {'3336760419': 'Check', '3266396022': 'Check'}
    side_pots: list[Dict[str, any]] = None  # List of dicts with 'amount' and 'eligible_players' keys

    @classmethod
    def from_message(cls, message: Dict[str, Any]) -> 'RoundStateClient':
        """Create RoundStateClient from a message dictionary"""
        return cls(
            round_num=message['round_num'],
            round=message['round'],
            community_cards=message['community_cards'],
            pot=message['pot'],
            current_player=message['current_player'],
            current_bet=message['current_bet'],
            min_raise=message['min_raise'],
            max_raise=message['max_raise'],
            player_bets=message['player_bets'],
            player_actions=message['player_actions'],
            side_pots=message.get('side_pots', [])
        )
```

**PokerAction and PokerRound Enums:**
```python
from enum import Enum

class PokerAction(Enum):
    FOLD = 1
    CHECK = 2
    CALL = 3
    RAISE = 4
    ALL_IN = 5

class PokerRound(Enum):
    PREFLOP = 0
    FLOP = 1
    TURN = 2
    RIVER = 3
```

**Bot abstract class:**
```python
from abc import ABC, abstractmethod
from typing import List, Tuple

from type.round_state import RoundStateClient
from type.poker_action import PokerAction

class Bot(ABC):
    def __init__(self) -> None:
        """ Initializes the player. """
        self.id = None
        pass

    def set_id(self, player_id: int) -> None:
        """ Sets the player ID. """
        self.id = player_id

    @abstractmethod
    def on_start(self, starting_chips: int, player_hands: List[str], blind_amount: int, big_blind_player_id: int, small_blind_player_id: int, all_players: List[int]) -> None:
        """ Called when the game starts. """
        pass

    @abstractmethod
    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the start of each round. """
        pass

    @abstractmethod
    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """ Called when it is the player's turn to act. """
        pass

    @abstractmethod
    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int) -> None:
        """ Called at the end of each round. """
        pass

    @abstractmethod
    def on_end_game(self, round_state: RoundStateClient, player_score: float, all_scores: dict, active_players_hands: dict) -> None:
        """ Called at the end of the game. """
        pass
```

    RESPONSE:
    ```python
import random
from typing import List, Tuple, Dict

from bot import Bot
from type.poker_action import PokerAction
from type.round_state import RoundStateClient

# Optional fast hand-strength evaluator
try:
    from treys import Evaluator, Card, Deck
    _HAVE_TREYS = True
except ImportError:  # Fallback to a simple heuristic evaluator
    _HAVE_TREYS = False


class SimplePlayer(Bot):
    """
    A very compact yet surprisingly strong No-Limit Texas Hold’em bot.
    Core ideas:
      • Pre-flop: fixed hand-strength chart with position awareness.
      • Post-flop: Hand-strength (equity) Monte-Carlo estimate (fast with
        treys, heuristic fallback otherwise) turned into an aggression
        factor.
      • Always double-checks action legality before sending it to the
        engine in order to avoid auto-folds.
    """

    # ----- CONFIGURABLE CONSTANTS -----
    PREFLOP_PREMIUM = {
        "AA", "KK", "QQ", "JJ", "AKs"
    }
    PREFLOP_STRONG = {
        "TT", "99", "88", "AQs", "AJs", "AK",
        "KQs", "77", "66"
    }
    MONTE_CARLO_ITERS = 75          # Equity simulations per decision
    AGGRO_THRESHOLD = 0.70          # Equity for strong aggression
    CALL_THRESHOLD = 0.45           # Minimum equity to continue
    RAISE_FACTOR = 2.5              # Pot-sized raise factor
    MIN_STACK_FOR_ALLIN = 0.4       # Push if stack/pot < this fraction
    RANDOM_SEED = 7                 # Fixed seed for reproducibility
    # ----------------------------------

    def __init__(self):
        super().__init__()
        random.seed(self.RANDOM_SEED)
        self.evaluator = Evaluator() if _HAVE_TREYS else None
        self.starting_stack = 0
        self.big_blind = 0
        self.hole_cards: List[str] = []

    # ------------------------------------------------------------------ #
    #  ENGINE CALLBACKS
    # ------------------------------------------------------------------ #
    def on_start(
        self,
        starting_chips: int,
        player_hands: List[str],
        blind_amount: int,
        big_blind_player_id: int,
        small_blind_player_id: int,
        all_players: List[int],
    ):
        self.starting_stack = starting_chips
        self.big_blind = blind_amount
        # The server gives us our hole cards for the first hand here.
        # Store them so that on_round_start simply refreshes later.
        self.hole_cards = player_hands

    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):
        # Update hole cards if the engine provides them per hand.
        # Tries multiple possible attribute names for compatibility.
        possible_fields = ["player_hands", "hole_cards", "hands"]
        for field in possible_fields:
            if hasattr(round_state, field):
                hands = getattr(round_state, field)
                # The attribute might be a dict keyed by player id or a list.
                if isinstance(hands, dict):
                    self.hole_cards = hands.get(str(self.id), hands.get(self.id, self.hole_cards))
                else:
                    self.hole_cards = hands
                break

    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:
        """
        Main decision method – selects an action plus amount (0 if not used).
        """
        # ---------------- Data extraction ---------------- #
        community = round_state.community_cards
        pot = round_state.pot
        cur_bet = round_state.current_bet
        min_raise = round_state.min_raise
        max_raise = min(round_state.max_raise, remaining_chips)
        player_bets: Dict[str, int] = round_state.player_bets or {}
        my_bet = player_bets.get(str(self.id), 0)
        to_call = max(0, cur_bet - my_bet)

        # ---------------- PREFLOP LOGIC ------------------ #
        if round_state.round.lower() == "preflop":
            action, amount = self._preflop_strategy(to_call, min_raise, max_raise, pot)
            return self._ensure_legal_action(action, amount, to_call, min_raise, max_raise)

        # ---------------- POSTFLOP LOGIC ----------------- #
        active_players = len(round_state.current_player)
        win_prob = self._estimate_equity(self.hole_cards, community, active_players)

        # Decide based on equity
        if win_prob >= self.AGGRO_THRESHOLD:
            # Big hand – either shove or big raise.
            if remaining_chips <= self.MIN_STACK_FOR_ALLIN * pot:
                return self._ensure_legal_action(PokerAction.ALL_IN, 0, to_call, min_raise, max_raise)
            else:
                target = int(min(max_raise, pot * self.RAISE_FACTOR))
                return self._ensure_legal_action(PokerAction.RAISE, target, to_call, min_raise, max_raise)
        elif win_prob >= self.CALL_THRESHOLD:
            # Medium strength -> call/check
            if to_call == 0:
                return PokerAction.CHECK, 0
            else:
                return self._ensure_legal_action(PokerAction.CALL, 0, to_call, min_raise, max_raise)
        else:
            # Weak -> fold/check
            if to_call == 0:
                return PokerAction.CHECK, 0
            return PokerAction.FOLD, 0

    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):
        # Nothing fancy – could add learning here.
        pass

    def on_end_game(
        self,
        round_state: RoundStateClient,
        player_score: float,
        all_scores: dict,
        active_players_hands: dict,
    ):
        # Persist any statistics if required (not used).
        pass

    # ------------------------------------------------------------------ #
    #  INTERNAL STRATEGY / UTILITY
    # ------------------------------------------------------------------ #
    def _preflop_strategy(
        self, to_call: int, min_raise: int, max_raise: int, pot: int
    ) -> Tuple[PokerAction, int]:
        """Very small pre-flop opening chart with position agnosticism."""
        card1, card2 = self.hole_cards
        rank1, suit1 = card1[0], card1[1]
        rank2, suit2 = card2[0], card2[1]
        suited = suit1 == suit2
        ranks = "".join(sorted([rank1, rank2], reverse=True))
        hand_key = f"{ranks}{'s' if suited else ''}"

        if hand_key in self.PREFLOP_PREMIUM:
            # Raise / 3-bet
            target = min(max_raise, max(min_raise * 3, pot + min_raise))
            return PokerAction.RAISE, target
        elif hand_key in self.PREFLOP_STRONG:
            if to_call == 0:
                target = min(max_raise, min_raise * 3)
                return PokerAction.RAISE, target
            else:
                # Facing raise – just call unless huge.
                return PokerAction.CALL, 0
        else:
            # Marginal hands limp if cheap, otherwise fold.
            if to_call == 0:
                return PokerAction.CHECK, 0
            elif to_call <= self.big_blind:
                return PokerAction.CALL, 0
            return PokerAction.FOLD, 0

    # --------------- Equity calculation ---------------- #
    def _estimate_equity(
        self, hole_cards: List[str], community_cards: List[str], num_players: int
    ) -> float:
        """Monte-Carlo simulation of winning probability."""
        # Simple heuristic fallback
        if not _HAVE_TREYS:
            return self._heuristic_equity(hole_cards, community_cards, num_players)

        needed_community = 5 - len(community_cards)
        my_card_ints = [Card.new(c) for c in hole_cards]
        board_ints = [Card.new(c) for c in community_cards]

        wins = ties = 0
        iterations = self.MONTE_CARLO_ITERS
        evaluator = self.evaluator

        full_deck = Card.get_full_deck()
        dead_cards = set(my_card_ints + board_ints)

        for _ in range(iterations):
            deck = [c for c in full_deck if c not in dead_cards]
            random.shuffle(deck)

            # Draw remaining community
            drawn_community = deck[:needed_community]
            deck_pos = needed_community
            full_board = board_ints + drawn_community

            my_rank = evaluator.evaluate(full_board, my_card_ints)

            # Opponents
            won = True
            tie = False
            for _opp in range(num_players - 1):
                opp_hole = deck[deck_pos : deck_pos + 2]
                deck_pos += 2
                opp_rank = evaluator.evaluate(full_board, opp_hole)
                if opp_rank < my_rank:
                    won = False
                    break
                if opp_rank == my_rank:
                    tie = True
            if won:
                if tie:
                    ties += 1
                else:
                    wins += 1

        return (wins + ties * 0.5) / max(1, iterations)

    @staticmethod
    def _heuristic_equity(hole_cards: List[str], community_cards: List[str], players: int) -> float:
        """
        Extremely light-weight heuristic: counts pairs / suitedness.
        Returns equity approximation between 0-1.
        """
        card1, card2 = hole_cards
        p = 0.25  # base
        # Pair bonus
        if card1[0] == card2[0]:
            p += 0.25
        # Suited bonus
        if card1[1] == card2[1]:
            p += 0.05
        # High-card bonus
        high = {"A": 0.15, "K": 0.10, "Q": 0.08, "J": 0.06, "T": 0.04}
        p += high.get(card1[0], 0)
        p += high.get(card2[0], 0)
        # Board improvement – very naïve
        p += 0.03 * len(community_cards)
        # Multi-way penalty
        p = max(0.0, p - 0.05 * (players - 2))
        return min(1.0, p)

    # --------------- Safety guard ---------------------- #
    def _ensure_legal_action(
        self,
        action: PokerAction,
        amount: int,
        to_call: int,
        min_raise: int,
        max_raise: int,
    ) -> Tuple[PokerAction, int]:
        """
        Guarantees the returned action complies with engine requirements, else
        downgrades gracefully (e.g., RAISE→CALL, CALL→CHECK, …).
        """
        # Clamp amount into bounds
        amount = max(0, min(amount, max_raise))

        if action == PokerAction.RAISE:
            if amount < min_raise or amount <= to_call:
                # Invalid raise – fallback to call if possible
                if to_call > 0:
                    return PokerAction.CALL, 0
                else:
                    return PokerAction.CHECK, 0
            return action, amount

        if action == PokerAction.CALL and to_call == 0:
            return PokerAction.CHECK, 0

        if action == PokerAction.CHECK and to_call > 0:
            # Can't check – call if cheap, otherwise fold
            if to_call <= self.big_blind:
                return PokerAction.CALL, 0
            return PokerAction.FOLD, 0

        # ALL_IN is always legal – no modification needed
        return action, amount
```

```text
treys
```


    RAW API RESPONSE:
    {
  "choices": [
    {
      "message": {
        "content": "```python\nimport random\nfrom typing import List, Tuple, Dict\n\nfrom bot import Bot\nfrom type.poker_action import PokerAction\nfrom type.round_state import RoundStateClient\n\n# Optional fast hand-strength evaluator\ntry:\n    from treys import Evaluator, Card, Deck\n    _HAVE_TREYS = True\nexcept ImportError:  # Fallback to a simple heuristic evaluator\n    _HAVE_TREYS = False\n\n\nclass SimplePlayer(Bot):\n    \"\"\"\n    A very compact yet surprisingly strong No-Limit Texas Hold\u2019em bot.\n    Core ideas:\n      \u2022 Pre-flop: fixed hand-strength chart with position awareness.\n      \u2022 Post-flop: Hand-strength (equity) Monte-Carlo estimate (fast with\n        treys, heuristic fallback otherwise) turned into an aggression\n        factor.\n      \u2022 Always double-checks action legality before sending it to the\n        engine in order to avoid auto-folds.\n    \"\"\"\n\n    # ----- CONFIGURABLE CONSTANTS -----\n    PREFLOP_PREMIUM = {\n        \"AA\", \"KK\", \"QQ\", \"JJ\", \"AKs\"\n    }\n    PREFLOP_STRONG = {\n        \"TT\", \"99\", \"88\", \"AQs\", \"AJs\", \"AK\",\n        \"KQs\", \"77\", \"66\"\n    }\n    MONTE_CARLO_ITERS = 75          # Equity simulations per decision\n    AGGRO_THRESHOLD = 0.70          # Equity for strong aggression\n    CALL_THRESHOLD = 0.45           # Minimum equity to continue\n    RAISE_FACTOR = 2.5              # Pot-sized raise factor\n    MIN_STACK_FOR_ALLIN = 0.4       # Push if stack/pot < this fraction\n    RANDOM_SEED = 7                 # Fixed seed for reproducibility\n    # ----------------------------------\n\n    def __init__(self):\n        super().__init__()\n        random.seed(self.RANDOM_SEED)\n        self.evaluator = Evaluator() if _HAVE_TREYS else None\n        self.starting_stack = 0\n        self.big_blind = 0\n        self.hole_cards: List[str] = []\n\n    # ------------------------------------------------------------------ #\n    #  ENGINE CALLBACKS\n    # ------------------------------------------------------------------ #\n    def on_start(\n        self,\n        starting_chips: int,\n        player_hands: List[str],\n        blind_amount: int,\n        big_blind_player_id: int,\n        small_blind_player_id: int,\n        all_players: List[int],\n    ):\n        self.starting_stack = starting_chips\n        self.big_blind = blind_amount\n        # The server gives us our hole cards for the first hand here.\n        # Store them so that on_round_start simply refreshes later.\n        self.hole_cards = player_hands\n\n    def on_round_start(self, round_state: RoundStateClient, remaining_chips: int):\n        # Update hole cards if the engine provides them per hand.\n        # Tries multiple possible attribute names for compatibility.\n        possible_fields = [\"player_hands\", \"hole_cards\", \"hands\"]\n        for field in possible_fields:\n            if hasattr(round_state, field):\n                hands = getattr(round_state, field)\n                # The attribute might be a dict keyed by player id or a list.\n                if isinstance(hands, dict):\n                    self.hole_cards = hands.get(str(self.id), hands.get(self.id, self.hole_cards))\n                else:\n                    self.hole_cards = hands\n                break\n\n    def get_action(self, round_state: RoundStateClient, remaining_chips: int) -> Tuple[PokerAction, int]:\n        \"\"\"\n        Main decision method \u2013 selects an action plus amount (0 if not used).\n        \"\"\"\n        # ---------------- Data extraction ---------------- #\n        community = round_state.community_cards\n        pot = round_state.pot\n        cur_bet = round_state.current_bet\n        min_raise = round_state.min_raise\n        max_raise = min(round_state.max_raise, remaining_chips)\n        player_bets: Dict[str, int] = round_state.player_bets or {}\n        my_bet = player_bets.get(str(self.id), 0)\n        to_call = max(0, cur_bet - my_bet)\n\n        # ---------------- PREFLOP LOGIC ------------------ #\n        if round_state.round.lower() == \"preflop\":\n            action, amount = self._preflop_strategy(to_call, min_raise, max_raise, pot)\n            return self._ensure_legal_action(action, amount, to_call, min_raise, max_raise)\n\n        # ---------------- POSTFLOP LOGIC ----------------- #\n        active_players = len(round_state.current_player)\n        win_prob = self._estimate_equity(self.hole_cards, community, active_players)\n\n        # Decide based on equity\n        if win_prob >= self.AGGRO_THRESHOLD:\n            # Big hand \u2013 either shove or big raise.\n            if remaining_chips <= self.MIN_STACK_FOR_ALLIN * pot:\n                return self._ensure_legal_action(PokerAction.ALL_IN, 0, to_call, min_raise, max_raise)\n            else:\n                target = int(min(max_raise, pot * self.RAISE_FACTOR))\n                return self._ensure_legal_action(PokerAction.RAISE, target, to_call, min_raise, max_raise)\n        elif win_prob >= self.CALL_THRESHOLD:\n            # Medium strength -> call/check\n            if to_call == 0:\n                return PokerAction.CHECK, 0\n            else:\n                return self._ensure_legal_action(PokerAction.CALL, 0, to_call, min_raise, max_raise)\n        else:\n            # Weak -> fold/check\n            if to_call == 0:\n                return PokerAction.CHECK, 0\n            return PokerAction.FOLD, 0\n\n    def on_end_round(self, round_state: RoundStateClient, remaining_chips: int):\n        # Nothing fancy \u2013 could add learning here.\n        pass\n\n    def on_end_game(\n        self,\n        round_state: RoundStateClient,\n        player_score: float,\n        all_scores: dict,\n        active_players_hands: dict,\n    ):\n        # Persist any statistics if required (not used).\n        pass\n\n    # ------------------------------------------------------------------ #\n    #  INTERNAL STRATEGY / UTILITY\n    # ------------------------------------------------------------------ #\n    def _preflop_strategy(\n        self, to_call: int, min_raise: int, max_raise: int, pot: int\n    ) -> Tuple[PokerAction, int]:\n        \"\"\"Very small pre-flop opening chart with position agnosticism.\"\"\"\n        card1, card2 = self.hole_cards\n        rank1, suit1 = card1[0], card1[1]\n        rank2, suit2 = card2[0], card2[1]\n        suited = suit1 == suit2\n        ranks = \"\".join(sorted([rank1, rank2], reverse=True))\n        hand_key = f\"{ranks}{'s' if suited else ''}\"\n\n        if hand_key in self.PREFLOP_PREMIUM:\n            # Raise / 3-bet\n            target = min(max_raise, max(min_raise * 3, pot + min_raise))\n            return PokerAction.RAISE, target\n        elif hand_key in self.PREFLOP_STRONG:\n            if to_call == 0:\n                target = min(max_raise, min_raise * 3)\n                return PokerAction.RAISE, target\n            else:\n                # Facing raise \u2013 just call unless huge.\n                return PokerAction.CALL, 0\n        else:\n            # Marginal hands limp if cheap, otherwise fold.\n            if to_call == 0:\n                return PokerAction.CHECK, 0\n            elif to_call <= self.big_blind:\n                return PokerAction.CALL, 0\n            return PokerAction.FOLD, 0\n\n    # --------------- Equity calculation ---------------- #\n    def _estimate_equity(\n        self, hole_cards: List[str], community_cards: List[str], num_players: int\n    ) -> float:\n        \"\"\"Monte-Carlo simulation of winning probability.\"\"\"\n        # Simple heuristic fallback\n        if not _HAVE_TREYS:\n            return self._heuristic_equity(hole_cards, community_cards, num_players)\n\n        needed_community = 5 - len(community_cards)\n        my_card_ints = [Card.new(c) for c in hole_cards]\n        board_ints = [Card.new(c) for c in community_cards]\n\n        wins = ties = 0\n        iterations = self.MONTE_CARLO_ITERS\n        evaluator = self.evaluator\n\n        full_deck = Card.get_full_deck()\n        dead_cards = set(my_card_ints + board_ints)\n\n        for _ in range(iterations):\n            deck = [c for c in full_deck if c not in dead_cards]\n            random.shuffle(deck)\n\n            # Draw remaining community\n            drawn_community = deck[:needed_community]\n            deck_pos = needed_community\n            full_board = board_ints + drawn_community\n\n            my_rank = evaluator.evaluate(full_board, my_card_ints)\n\n            # Opponents\n            won = True\n            tie = False\n            for _opp in range(num_players - 1):\n                opp_hole = deck[deck_pos : deck_pos + 2]\n                deck_pos += 2\n                opp_rank = evaluator.evaluate(full_board, opp_hole)\n                if opp_rank < my_rank:\n                    won = False\n                    break\n                if opp_rank == my_rank:\n                    tie = True\n            if won:\n                if tie:\n                    ties += 1\n                else:\n                    wins += 1\n\n        return (wins + ties * 0.5) / max(1, iterations)\n\n    @staticmethod\n    def _heuristic_equity(hole_cards: List[str], community_cards: List[str], players: int) -> float:\n        \"\"\"\n        Extremely light-weight heuristic: counts pairs / suitedness.\n        Returns equity approximation between 0-1.\n        \"\"\"\n        card1, card2 = hole_cards\n        p = 0.25  # base\n        # Pair bonus\n        if card1[0] == card2[0]:\n            p += 0.25\n        # Suited bonus\n        if card1[1] == card2[1]:\n            p += 0.05\n        # High-card bonus\n        high = {\"A\": 0.15, \"K\": 0.10, \"Q\": 0.08, \"J\": 0.06, \"T\": 0.04}\n        p += high.get(card1[0], 0)\n        p += high.get(card2[0], 0)\n        # Board improvement \u2013 very na\u00efve\n        p += 0.03 * len(community_cards)\n        # Multi-way penalty\n        p = max(0.0, p - 0.05 * (players - 2))\n        return min(1.0, p)\n\n    # --------------- Safety guard ---------------------- #\n    def _ensure_legal_action(\n        self,\n        action: PokerAction,\n        amount: int,\n        to_call: int,\n        min_raise: int,\n        max_raise: int,\n    ) -> Tuple[PokerAction, int]:\n        \"\"\"\n        Guarantees the returned action complies with engine requirements, else\n        downgrades gracefully (e.g., RAISE\u2192CALL, CALL\u2192CHECK, \u2026).\n        \"\"\"\n        # Clamp amount into bounds\n        amount = max(0, min(amount, max_raise))\n\n        if action == PokerAction.RAISE:\n            if amount < min_raise or amount <= to_call:\n                # Invalid raise \u2013 fallback to call if possible\n                if to_call > 0:\n                    return PokerAction.CALL, 0\n                else:\n                    return PokerAction.CHECK, 0\n            return action, amount\n\n        if action == PokerAction.CALL and to_call == 0:\n            return PokerAction.CHECK, 0\n\n        if action == PokerAction.CHECK and to_call > 0:\n            # Can't check \u2013 call if cheap, otherwise fold\n            if to_call <= self.big_blind:\n                return PokerAction.CALL, 0\n            return PokerAction.FOLD, 0\n\n        # ALL_IN is always legal \u2013 no modification needed\n        return action, amount\n```\n\n```text\ntreys\n```\n",
        "role": "assistant"
      },
      "finish_reason": "stop"
    }
  ],
  "usage": {
    "input_tokens": 2315,
    "input_tokens_details": {
      "cached_tokens": 0
    },
    "output_tokens": 5693,
    "output_tokens_details": {
      "reasoning_tokens": 3072
    },
    "total_tokens": 8008
  },
  "model": "o3-pro-2025-06-10",
  "id": "resp_6897f7b9242881a09017b84d820fd13206dda935efe1941d",
  "object": "chat.completion",
  "reasoning": {
    "id": "rs_6897f885845081a0b0972dcbfd2872e906dda935efe1941d",
    "type": "reasoning",
    "summary": []
  }
}
    ================================================================================
    